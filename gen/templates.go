package main

import "text/template"

var structFormat = template.Must(template.New("parent").Parse(`
{{ .TypeDoc }}
type {{ .Name }} struct {
{{ range .Fields }}
    {{ . }}
{{ end }}
}
`))

var modelFormat = template.Must(template.New("parent").Parse(`// Code generated DO NOT EDIT
// This file was generated by robots at
// {{ .Timestamp }}
package pom


type XMLInner struct {
	InnerXML string ` + "`xml:\",innerxml\"`" + `
}

type XMLAnyElement struct {
	Comment  xml.Comment        ` + "`xml:\",comment\"`" + `
	Elements []XMLAnyElementEntry ` + "`xml:\",any\"`" + `
}

type XMLAnyElementEntry struct {
	XMLName xml.Name
	Value   string ` + "`xml:\",chardata\"`" + `
	Comment xml.Comment ` + "`xml:\",comment\"`" + `
}

// MarshalXML Remooves the Space field from the XMLName field (Because why does that even exist?)
func (m XMLAnyElementEntry) MarshalXML(e *xml.Encoder, start xml.StartElement) error {

	// Custom marshal is just to get rid of the annoying Space field for XMLName.
	// Converting to a type without a CustomMarshaler so we don't loop forever.
	return e.Encode(xmlMapEntry{XMLName: xml.Name{Local: m.XMLName.Local, Space: ""}, Value: m.Value})
}

// XMLMap is a custom key used to let XML data parse maps
// Because it doesnt do that by default...for some reason.
type XMLMap map[string]string

type xmlMapEntry struct {
    XMLName xml.Name
    Value   string ` + "`xml:\",chardata\"`" + `
}

// MarshalXML marshals the map to XML, with each key in the map being a
// tag and it's corresponding value being it's contents.
func (m XMLMap) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    if len(m) == 0 {
        return nil
    }

    err := e.EncodeToken(start)
    if err != nil {
        return err
    }

    for k, v := range m {
        e.Encode(xmlMapEntry{XMLName: xml.Name{Local: k}, Value: v})
    }

    return e.EncodeToken(start.End())
}


// UnmarshalXML takes a key and turns it into a map
func (m *XMLMap) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
    *m = XMLMap{}
    for {
        var e xmlMapEntry

        err := d.Decode(&e)
        if err == io.EOF {
            break
        } else if err != nil {
            return err
        }

        (*m)[e.XMLName.Local] = e.Value
    }
    return nil
}

{{ range .Types }}
{{ . }}
{{ end }}
`))
