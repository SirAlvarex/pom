package main

import (
	"errors"
	"text/template"
)

var structFormat = template.Must(template.New("structv2").Funcs(template.FuncMap{
	"dict": func(values ...interface{}) (map[string]interface{}, error) {
		if len(values)%2 != 0 {
			return nil, errors.New("invalid dict call")
		}
		dict := make(map[string]interface{}, len(values)/2)
		for i := 0; i < len(values); i += 2 {
			key, ok := values[i].(string)
			if !ok {
				return nil, errors.New("dict keys must be strings")
			}
			dict[key] = values[i+1]
		}
		return dict, nil
	},
}).Parse(`
{{ range . }}
{{ .Doc }}
type {{ .Name }} struct {
{{ $parentName := .Name }}
{{ range .Fields }}
    {{ .Doc }}
    {{ .Name }} {{ if .IsSlice}}[]{{end}}{{if .IsPointer}}*{{end}}{{ .Type }} {{ .Tag }}
{{ end }}
}

{{ range .Fields }}
{{ template "getMethod" dict "ParentName" $parentName "Field" . }}
{{ template "setMethod" dict "ParentName" $parentName "Field" . }}
{{ if .IsSlice }}
{{ template "updateMethod" dict "ParentName" $parentName "Field" . }}
{{ end }}
{{ end }}
{{ end }}
`))

// Define how get methods are templatized
var getMethod = template.Must(structFormat.New("getMethod").Parse(`
{{ with .Field }}
// Get{{.Name }} Gets the value of {{ .Name }} and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage: 
//   if value, ok := a.Get{{ .Name }}(); ok { 
//        fmt.Println(value)
//    }
{{- if .IsSlice }}
func (a *{{ $.ParentName }}) Get{{ .Name }}() (returnValue {{ if .IsSlice}}[]{{if .IsPointer}}*{{end}}{{end}}{{ .Type }}) {
{{- else }}
func (a *{{ $.ParentName }}) Get{{ .Name }}() (returnValue {{ if .IsSlice}}[]{{if .IsPointer}}*{{end}}{{end}}{{ .Type }}, exists bool) {
{{- end }}
    {{- if .IsSlice }}
    if a.{{ .Name }} != nil {
        return a.{{ .Name }}
    }
    return  []{{if .IsPointer}}*{{end}}{{ .DefaultValue }}
    {{- else if .IsPointer }}
    if a.{{ .Name }} != nil {
        return *a.{{ .Name }}, true
    }
    return  {{ .DefaultValue }}, false
    {{- else }}
    return a.{{ .Name }}, false
    {{- end }}
}
{{ end }}
`))

// Define how get methods are templatized
var setMethod = template.Must(structFormat.New("setMethod").Parse(`
{{ with .Field }}
// Set{{.Name }} will overwrite whatever value is currently set for {{ .Name }}.
// Usage: 
// a.Set{{.Name}}({{ .DefaultValue }})
func (a *{{ $.ParentName }}) Set{{ .Name }}(value {{ if .IsSlice}}[]{{if .IsPointer}}*{{end}}{{end}}{{ .Type }})  {
    {{- if or .IsSlice (not .IsPointer ) }}
    a.{{ .Name }} = value
    {{ else }}
    copy := value
    a.{{ .Name }} = &copy
    {{ end }}
}
{{ end }}
`))

// Define how get methods are templatized
var updateMethod = template.Must(structFormat.New("updateMethod").Parse(`
{{ with .Field }}
// Update{{.Name }} will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage: 
// value := {{ .Type }}{ }
// a.Update{{ .Name }}(value, 2)
func (a *{{ $.ParentName }}) Update{{ .Name }}(value {{if .IsPointer}}*{{end}}{{ .Type }}, index int) {
    current := a.Get{{.Name}}()
    if len(current) > index {
        a.{{ .Name }}[index] = value
    }
    a.{{ .Name }} = append(current, value)
}
// Add{{.Name }} adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage: 
// value := {{ .Type }}{ }
// a.Add{{ .Name }}(value)
func (a *{{ $.ParentName }}) Add{{ .Name }}(value {{if .IsPointer}}*{{end}}{{ .Type }}) {
    a.{{ .Name }} = append(a.{{ .Name }}, value)
}
{{ end }}
`))

var modelFormat = template.Must(template.New("parent").Parse(`// Package pom
// Code generated DO NOT EDIT
// This file was generated by robots at
// {{ .Timestamp }}
package pom

// XMLInner describes the 'any' type field in XML, which is effectively untyped.
// We just take whatever is in that field and unmarshal it directly
type XMLInner struct {
	InnerXML string ` + "`xml:\",innerxml\"`" + `
}

// XMLProperties is the subtype for POM Properties.
// In the XSD, properties are defined as an "Any" type
// However, this anytype has a consistent format.
// So it isn't an anytype...despite saying so...
type XMLProperties struct {
	Comment  xml.Comment        ` + "`xml:\",comment\"`" + `
	Elements []XMLPropertiesEntry ` + "`xml:\",any\"`" + `
}

// XMLPropertiesEntry contains the actual value of the properties
type XMLPropertiesEntry struct {
	XMLName xml.Name
	Value   string ` + "`xml:\",chardata\"`" + `
	Comment xml.Comment ` + "`xml:\",comment\"`" + `
}

// MarshalXML Remooves the Space field from the XMLName field (Because why does that even exist?)
func (m XMLPropertiesEntry) MarshalXML(e *xml.Encoder, start xml.StartElement) error {

	// Custom marshal is just to get rid of the annoying Space field for XMLName.
	// Converting to a type without a CustomMarshaler so we don't loop forever.
	return e.Encode(xmlMapEntry{XMLName: xml.Name{Local: m.XMLName.Local, Space: ""}, Value: m.Value})
}

// XMLMap is a custom key used to let XML data parse maps
// Because it doesnt do that by default...for some reason.
type XMLMap map[string]string

type xmlMapEntry struct {
    XMLName xml.Name
    Value   string ` + "`xml:\",chardata\"`" + `
}

// MarshalXML marshals the map to XML, with each key in the map being a
// tag and it's corresponding value being it's contents.
func (m XMLMap) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
    if len(m) == 0 {
        return nil
    }

    err := e.EncodeToken(start)
    if err != nil {
        return err
    }

    for k, v := range m {
        e.Encode(xmlMapEntry{XMLName: xml.Name{Local: k}, Value: v})
    }

    return e.EncodeToken(start.End())
}


// UnmarshalXML takes a key and turns it into a map
func (m *XMLMap) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
    *m = XMLMap{}
    for {
        var e xmlMapEntry

        err := d.Decode(&e)
        if err == io.EOF {
            break
        } else if err != nil {
            return err
        }

        (*m)[e.XMLName.Local] = e.Value
    }
    return nil
}

{{ range .Types }}
{{ . }}
{{ end }}
`))
