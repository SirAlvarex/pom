// Package pom
// Code generated DO NOT EDIT
// This file was generated by robots at
// 2019-08-30 10:12:03.8586703 -0700 PDT m=+4.247884401
package pom

import (
	"encoding/xml"
	"io"
)

// XMLInner describes the 'any' type field in XML, which is effectively untyped.
// We just take whatever is in that field and unmarshal it directly
type XMLInner struct {
	InnerXML string `xml:",innerxml"`
}

// XMLProperties is the subtype for POM Properties.
// In the XSD, properties are defined as an "Any" type
// However, this anytype has a consistent format.
// So it isn't an anytype...despite saying so...
type XMLProperties struct {
	Comment  xml.Comment          `xml:",comment"`
	Elements []XMLPropertiesEntry `xml:",any"`
}

// XMLPropertiesEntry contains the actual value of the properties
type XMLPropertiesEntry struct {
	XMLName xml.Name
	Value   string      `xml:",chardata"`
	Comment xml.Comment `xml:",comment"`
}

// MarshalXML Remooves the Space field from the XMLName field (Because why does that even exist?)
func (m XMLPropertiesEntry) MarshalXML(e *xml.Encoder, start xml.StartElement) error {

	// Custom marshal is just to get rid of the annoying Space field for XMLName.
	// Converting to a type without a CustomMarshaler so we don't loop forever.
	return e.Encode(xmlMapEntry{XMLName: xml.Name{Local: m.XMLName.Local, Space: ""}, Value: m.Value})
}

// XMLMap is a custom key used to let XML data parse maps
// Because it doesnt do that by default...for some reason.
type XMLMap map[string]string

type xmlMapEntry struct {
	XMLName xml.Name
	Value   string `xml:",chardata"`
}

// MarshalXML marshals the map to XML, with each key in the map being a
// tag and it's corresponding value being it's contents.
func (m XMLMap) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if len(m) == 0 {
		return nil
	}

	err := e.EncodeToken(start)
	if err != nil {
		return err
	}

	for k, v := range m {
		e.Encode(xmlMapEntry{XMLName: xml.Name{Local: k}, Value: v})
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML takes a key and turns it into a map
func (m *XMLMap) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	*m = XMLMap{}
	for {
		var e xmlMapEntry

		err := d.Decode(&e)
		if err == io.EOF {
			break
		} else if err != nil {
			return err
		}

		(*m)[e.XMLName.Local] = e.Value
	}
	return nil
}

// SequenceLicense contains the subelements for iterables in XML
type SequenceLicense struct {
	Comment string `xml:",comment"`

	License []*License `xml:"license,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceLicense) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequenceLicense) SetComment(value string) {
	a.Comment = value

}

// GetLicense Gets the value of License and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetLicense(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceLicense) GetLicense() (returnValue []*License) {
	if a.License != nil {
		return a.License
	}
	return []*License{}
}

// SetLicense will overwrite whatever value is currently set for License.
// Usage:
// a.SetLicense(License{})
func (a *SequenceLicense) SetLicense(value []*License) {
	a.License = value

}

// UpdateLicense will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := License{ }
// a.UpdateLicense(value, 2)
func (a *SequenceLicense) UpdateLicense(value *License, index int) {
	current := a.GetLicense()
	if len(current) > index {
		a.License[index] = value
	}
	a.License = append(current, value)
}

// AddLicense adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := License{ }
// a.AddLicense(value)
func (a *SequenceLicense) AddLicense(value *License) {
	a.License = append(a.License, value)
}

// SequenceDeveloper contains the subelements for iterables in XML
type SequenceDeveloper struct {
	Comment string `xml:",comment"`

	Developer []*Developer `xml:"developer,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceDeveloper) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequenceDeveloper) SetComment(value string) {
	a.Comment = value

}

// GetDeveloper Gets the value of Developer and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetDeveloper(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceDeveloper) GetDeveloper() (returnValue []*Developer) {
	if a.Developer != nil {
		return a.Developer
	}
	return []*Developer{}
}

// SetDeveloper will overwrite whatever value is currently set for Developer.
// Usage:
// a.SetDeveloper(Developer{})
func (a *SequenceDeveloper) SetDeveloper(value []*Developer) {
	a.Developer = value

}

// UpdateDeveloper will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := Developer{ }
// a.UpdateDeveloper(value, 2)
func (a *SequenceDeveloper) UpdateDeveloper(value *Developer, index int) {
	current := a.GetDeveloper()
	if len(current) > index {
		a.Developer[index] = value
	}
	a.Developer = append(current, value)
}

// AddDeveloper adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := Developer{ }
// a.AddDeveloper(value)
func (a *SequenceDeveloper) AddDeveloper(value *Developer) {
	a.Developer = append(a.Developer, value)
}

// SequenceContributor contains the subelements for iterables in XML
type SequenceContributor struct {
	Comment string `xml:",comment"`

	Contributor []*Contributor `xml:"contributor,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceContributor) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequenceContributor) SetComment(value string) {
	a.Comment = value

}

// GetContributor Gets the value of Contributor and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetContributor(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceContributor) GetContributor() (returnValue []*Contributor) {
	if a.Contributor != nil {
		return a.Contributor
	}
	return []*Contributor{}
}

// SetContributor will overwrite whatever value is currently set for Contributor.
// Usage:
// a.SetContributor(Contributor{})
func (a *SequenceContributor) SetContributor(value []*Contributor) {
	a.Contributor = value

}

// UpdateContributor will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := Contributor{ }
// a.UpdateContributor(value, 2)
func (a *SequenceContributor) UpdateContributor(value *Contributor, index int) {
	current := a.GetContributor()
	if len(current) > index {
		a.Contributor[index] = value
	}
	a.Contributor = append(current, value)
}

// AddContributor adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := Contributor{ }
// a.AddContributor(value)
func (a *SequenceContributor) AddContributor(value *Contributor) {
	a.Contributor = append(a.Contributor, value)
}

// SequenceMailingList contains the subelements for iterables in XML
type SequenceMailingList struct {
	Comment string `xml:",comment"`

	MailingList []*MailingList `xml:"mailingList,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceMailingList) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequenceMailingList) SetComment(value string) {
	a.Comment = value

}

// GetMailingList Gets the value of MailingList and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetMailingList(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceMailingList) GetMailingList() (returnValue []*MailingList) {
	if a.MailingList != nil {
		return a.MailingList
	}
	return []*MailingList{}
}

// SetMailingList will overwrite whatever value is currently set for MailingList.
// Usage:
// a.SetMailingList(MailingList{})
func (a *SequenceMailingList) SetMailingList(value []*MailingList) {
	a.MailingList = value

}

// UpdateMailingList will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := MailingList{ }
// a.UpdateMailingList(value, 2)
func (a *SequenceMailingList) UpdateMailingList(value *MailingList, index int) {
	current := a.GetMailingList()
	if len(current) > index {
		a.MailingList[index] = value
	}
	a.MailingList = append(current, value)
}

// AddMailingList adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := MailingList{ }
// a.AddMailingList(value)
func (a *SequenceMailingList) AddMailingList(value *MailingList) {
	a.MailingList = append(a.MailingList, value)
}

// SequenceModule contains the subelements for iterables in XML
type SequenceModule struct {
	Comment string `xml:",comment"`

	Module []*string `xml:"module,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceModule) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequenceModule) SetComment(value string) {
	a.Comment = value

}

// GetModule Gets the value of Module and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetModule(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceModule) GetModule() (returnValue []*string) {
	if a.Module != nil {
		return a.Module
	}
	return []*string{}
}

// SetModule will overwrite whatever value is currently set for Module.
// Usage:
// a.SetModule(string{})
func (a *SequenceModule) SetModule(value []*string) {
	a.Module = value

}

// UpdateModule will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := string{ }
// a.UpdateModule(value, 2)
func (a *SequenceModule) UpdateModule(value *string, index int) {
	current := a.GetModule()
	if len(current) > index {
		a.Module[index] = value
	}
	a.Module = append(current, value)
}

// AddModule adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := string{ }
// a.AddModule(value)
func (a *SequenceModule) AddModule(value *string) {
	a.Module = append(a.Module, value)
}

// SequenceDependency contains the subelements for iterables in XML
type SequenceDependency struct {
	Comment string `xml:",comment"`

	Dependency []*Dependency `xml:"dependency,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceDependency) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequenceDependency) SetComment(value string) {
	a.Comment = value

}

// GetDependency Gets the value of Dependency and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetDependency(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceDependency) GetDependency() (returnValue []*Dependency) {
	if a.Dependency != nil {
		return a.Dependency
	}
	return []*Dependency{}
}

// SetDependency will overwrite whatever value is currently set for Dependency.
// Usage:
// a.SetDependency(Dependency{})
func (a *SequenceDependency) SetDependency(value []*Dependency) {
	a.Dependency = value

}

// UpdateDependency will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := Dependency{ }
// a.UpdateDependency(value, 2)
func (a *SequenceDependency) UpdateDependency(value *Dependency, index int) {
	current := a.GetDependency()
	if len(current) > index {
		a.Dependency[index] = value
	}
	a.Dependency = append(current, value)
}

// AddDependency adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := Dependency{ }
// a.AddDependency(value)
func (a *SequenceDependency) AddDependency(value *Dependency) {
	a.Dependency = append(a.Dependency, value)
}

// SequenceRepository contains the subelements for iterables in XML
type SequenceRepository struct {
	Comment string `xml:",comment"`

	Repository []*Repository `xml:"repository,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceRepository) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequenceRepository) SetComment(value string) {
	a.Comment = value

}

// GetRepository Gets the value of Repository and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetRepository(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceRepository) GetRepository() (returnValue []*Repository) {
	if a.Repository != nil {
		return a.Repository
	}
	return []*Repository{}
}

// SetRepository will overwrite whatever value is currently set for Repository.
// Usage:
// a.SetRepository(Repository{})
func (a *SequenceRepository) SetRepository(value []*Repository) {
	a.Repository = value

}

// UpdateRepository will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := Repository{ }
// a.UpdateRepository(value, 2)
func (a *SequenceRepository) UpdateRepository(value *Repository, index int) {
	current := a.GetRepository()
	if len(current) > index {
		a.Repository[index] = value
	}
	a.Repository = append(current, value)
}

// AddRepository adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := Repository{ }
// a.AddRepository(value)
func (a *SequenceRepository) AddRepository(value *Repository) {
	a.Repository = append(a.Repository, value)
}

// SequencePluginRepository contains the subelements for iterables in XML
type SequencePluginRepository struct {
	Comment string `xml:",comment"`

	PluginRepository []*Repository `xml:"pluginRepository,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequencePluginRepository) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequencePluginRepository) SetComment(value string) {
	a.Comment = value

}

// GetPluginRepository Gets the value of PluginRepository and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetPluginRepository(); ok {
//        fmt.Println(value)
//    }
func (a *SequencePluginRepository) GetPluginRepository() (returnValue []*Repository) {
	if a.PluginRepository != nil {
		return a.PluginRepository
	}
	return []*Repository{}
}

// SetPluginRepository will overwrite whatever value is currently set for PluginRepository.
// Usage:
// a.SetPluginRepository(Repository{})
func (a *SequencePluginRepository) SetPluginRepository(value []*Repository) {
	a.PluginRepository = value

}

// UpdatePluginRepository will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := Repository{ }
// a.UpdatePluginRepository(value, 2)
func (a *SequencePluginRepository) UpdatePluginRepository(value *Repository, index int) {
	current := a.GetPluginRepository()
	if len(current) > index {
		a.PluginRepository[index] = value
	}
	a.PluginRepository = append(current, value)
}

// AddPluginRepository adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := Repository{ }
// a.AddPluginRepository(value)
func (a *SequencePluginRepository) AddPluginRepository(value *Repository) {
	a.PluginRepository = append(a.PluginRepository, value)
}

// SequenceProfile contains the subelements for iterables in XML
type SequenceProfile struct {
	Comment string `xml:",comment"`

	Profile []*Profile `xml:"profile,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceProfile) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequenceProfile) SetComment(value string) {
	a.Comment = value

}

// GetProfile Gets the value of Profile and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetProfile(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceProfile) GetProfile() (returnValue []*Profile) {
	if a.Profile != nil {
		return a.Profile
	}
	return []*Profile{}
}

// SetProfile will overwrite whatever value is currently set for Profile.
// Usage:
// a.SetProfile(Profile{})
func (a *SequenceProfile) SetProfile(value []*Profile) {
	a.Profile = value

}

// UpdateProfile will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := Profile{ }
// a.UpdateProfile(value, 2)
func (a *SequenceProfile) UpdateProfile(value *Profile, index int) {
	current := a.GetProfile()
	if len(current) > index {
		a.Profile[index] = value
	}
	a.Profile = append(current, value)
}

// AddProfile adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := Profile{ }
// a.AddProfile(value)
func (a *SequenceProfile) AddProfile(value *Profile) {
	a.Profile = append(a.Profile, value)
}

// project The <code>&lt;project&gt;</code> element is the root of the descriptor.
//        The following table lists all of the possible child elements.
type project struct {

	/* ModelVersion Declares to which version of project descriptor this POM conforms.*/
	ModelVersion *string `xml:"modelVersion,omitempty"`

	/* Parent The location of the parent project, if one exists. Values from the parent
	   project will be the default for this project if they are left unspecified. The location
	   is given as a group ID, artifact ID and version.*/
	Parent *Parent `xml:"parent,omitempty"`

	/* GroupId A universally unique identifier for a project. It is normal to
	   use a fully-qualified package name to distinguish it from other
	   projects with a similar name (eg. <code>org.apache.maven</code>).*/
	GroupID *string `xml:"groupId,omitempty"`

	/* ArtifactId The identifier for this artifact that is unique within the group given by the
	   group ID. An artifact is something that is either produced or used by a project.
	   Examples of artifacts produced by Maven for a project include: JARs, source and binary
	   distributions, and WARs.*/
	ArtifactID *string `xml:"artifactId,omitempty"`

	/* Version The current version of the artifact produced by this project.*/
	Version *string `xml:"version,omitempty"`

	/* Packaging The type of artifact this project produces, for example <code>jar</code>
	     <code>war</code>
	     <code>ear</code>
	     <code>pom</code>.
	   Plugins can create their own packaging, and
	   therefore their own packaging types,
	   so this list does not contain all possible types.*/
	Packaging *string `xml:"packaging,omitempty"`

	/* Name The full name of the project.*/
	Name *string `xml:"name,omitempty"`

	/* Description A detailed description of the project, used by Maven whenever it needs to
	   describe the project, such as on the web site. While this element can be specified as
	   CDATA to enable the use of HTML tags within the description, it is discouraged to allow
	   plain text representation. If you need to modify the index page of the generated web
	   site, you are able to specify your own instead of adjusting this text.*/
	Description *string `xml:"description,omitempty"`

	/* Url The URL to the project's homepage.
	   <br><b>Default value is</b>: parent value [+ path adjustment] + (artifactId or project.directory property), or just parent value if
	   project's <code>child.project.url.inherit.append.path="false"</code>*/
	URL *string `xml:"url,omitempty"`

	/* InceptionYear The year of the project's inception, specified with 4 digits. This value is
	   used when generating copyright notices as well as being informational.*/
	InceptionYear *string `xml:"inceptionYear,omitempty"`

	/* Organization This element describes various attributes of the organization to which the
	   project belongs. These attributes are utilized when documentation is created (for
	   copyright notices and links).*/
	Organization *Organization `xml:"organization,omitempty"`

	/* Licenses This element describes all of the licenses for this project.
	   Each license is described by a <code>license</code> element, which
	   is then described by additional elements.
	   Projects should only list the license(s) that applies to the project
	   and not the licenses that apply to dependencies.
	   If multiple licenses are listed, it is assumed that the user can select
	   any of them, not that they must accept all.*/
	Licenses *SequenceLicense `xml:"licenses,omitempty"`

	/* Developers Describes the committers of a project.*/
	Developers *SequenceDeveloper `xml:"developers,omitempty"`

	/* Contributors Describes the contributors to a project that are not yet committers.*/
	Contributors *SequenceContributor `xml:"contributors,omitempty"`

	/* MailingLists Contains information about a project's mailing lists.*/
	MailingLists *SequenceMailingList `xml:"mailingLists,omitempty"`

	/* Prerequisites Describes the prerequisites in the build environment for this project.*/
	Prerequisites *Prerequisites `xml:"prerequisites,omitempty"`

	/* Modules The modules (sometimes called subprojects) to build as a part of this
	   project. Each module listed is a relative path to the directory containing the module.
	   To be consistent with the way default urls are calculated from parent, it is recommended
	   to have module names match artifact ids.*/
	Modules *SequenceModule `xml:"modules,omitempty"`

	/* Scm Specification for the SCM used by the project, such as CVS, Subversion, etc.*/
	Scm *Scm `xml:"scm,omitempty"`

	/* IssueManagement The project's issue management system information.*/
	IssueManagement *IssueManagement `xml:"issueManagement,omitempty"`

	/* CiManagement The project's continuous integration information.*/
	CiManagement *CiManagement `xml:"ciManagement,omitempty"`

	/* DistributionManagement Distribution information for a project that enables deployment of the site
	   and artifacts to remote web servers and repositories respectively.*/
	DistributionManagement *DistributionManagement `xml:"distributionManagement,omitempty"`

	/* Properties Properties that can be used throughout the POM as a substitution, and
	   are used as filters in resources if enabled.
	   The format is <code>&lt;name&gt;value&lt;/name&gt;</code>.*/
	Properties *XMLProperties `xml:"properties,omitempty"`

	/* DependencyManagement Default dependency information for projects that inherit from this one. The
	   dependencies in this section are not immediately resolved. Instead, when a POM derived
	   from this one declares a dependency described by a matching groupId and artifactId, the
	   version and other values from this section are used for that dependency if they were not
	   already specified.*/
	DependencyManagement *DependencyManagement `xml:"dependencyManagement,omitempty"`

	/* Dependencies This element describes all of the dependencies associated with a
	   project.
	   These dependencies are used to construct a classpath for your
	   project during the build process. They are automatically downloaded from the
	   repositories defined in this project.
	   See <a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">the
	   dependency mechanism</a> for more information.*/
	Dependencies *SequenceDependency `xml:"dependencies,omitempty"`

	/* Repositories The lists of the remote repositories for discovering dependencies and
	   extensions.*/
	Repositories *SequenceRepository `xml:"repositories,omitempty"`

	/* PluginRepositories The lists of the remote repositories for discovering plugins for builds and
	   reports.*/
	PluginRepositories *SequencePluginRepository `xml:"pluginRepositories,omitempty"`

	/* Build Information required to build the project.*/
	Build *Build `xml:"build,omitempty"`

	/* Reports <b>Deprecated</b>. Now ignored by Maven.*/
	Reports *XMLInner `xml:"reports,omitempty"`

	/* Reporting This element includes the specification of report plugins to use
	   to generate the reports on the Maven-generated site.
	   These reports will be run when a user executes <code>mvn site</code>.
	   All of the reports will be included in the navigation bar for browsing.*/
	Reporting *Reporting `xml:"reporting,omitempty"`

	/* Profiles A listing of project-local build profiles which will modify the build process
	   when activated.*/
	Profiles *SequenceProfile `xml:"profiles,omitempty"`

	Comment string `xml:",comment"`
}

// GetModelVersion Gets the value of ModelVersion and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetModelVersion(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetModelVersion() (returnValue string, exists bool) {
	if a.ModelVersion != nil {
		return *a.ModelVersion, true
	}
	return "", false
}

// SetModelVersion will overwrite whatever value is currently set for ModelVersion.
// Usage:
// a.SetModelVersion("")
func (a *project) SetModelVersion(value string) {
	copy := value
	a.ModelVersion = &copy

}

// GetParent Gets the value of Parent and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetParent(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetParent() (returnValue Parent, exists bool) {
	if a.Parent != nil {
		return *a.Parent, true
	}
	return Parent{}, false
}

// SetParent will overwrite whatever value is currently set for Parent.
// Usage:
// a.SetParent(Parent{})
func (a *project) SetParent(value Parent) {
	copy := value
	a.Parent = &copy

}

// GetGroupID Gets the value of GroupID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetGroupID(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetGroupID() (returnValue string, exists bool) {
	if a.GroupID != nil {
		return *a.GroupID, true
	}
	return "", false
}

// SetGroupID will overwrite whatever value is currently set for GroupID.
// Usage:
// a.SetGroupID("")
func (a *project) SetGroupID(value string) {
	copy := value
	a.GroupID = &copy

}

// GetArtifactID Gets the value of ArtifactID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetArtifactID(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetArtifactID() (returnValue string, exists bool) {
	if a.ArtifactID != nil {
		return *a.ArtifactID, true
	}
	return "", false
}

// SetArtifactID will overwrite whatever value is currently set for ArtifactID.
// Usage:
// a.SetArtifactID("")
func (a *project) SetArtifactID(value string) {
	copy := value
	a.ArtifactID = &copy

}

// GetVersion Gets the value of Version and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetVersion(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetVersion() (returnValue string, exists bool) {
	if a.Version != nil {
		return *a.Version, true
	}
	return "", false
}

// SetVersion will overwrite whatever value is currently set for Version.
// Usage:
// a.SetVersion("")
func (a *project) SetVersion(value string) {
	copy := value
	a.Version = &copy

}

// GetPackaging Gets the value of Packaging and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetPackaging(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetPackaging() (returnValue string, exists bool) {
	if a.Packaging != nil {
		return *a.Packaging, true
	}
	return "", false
}

// SetPackaging will overwrite whatever value is currently set for Packaging.
// Usage:
// a.SetPackaging("")
func (a *project) SetPackaging(value string) {
	copy := value
	a.Packaging = &copy

}

// GetName Gets the value of Name and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetName(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetName() (returnValue string, exists bool) {
	if a.Name != nil {
		return *a.Name, true
	}
	return "", false
}

// SetName will overwrite whatever value is currently set for Name.
// Usage:
// a.SetName("")
func (a *project) SetName(value string) {
	copy := value
	a.Name = &copy

}

// GetDescription Gets the value of Description and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetDescription(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetDescription() (returnValue string, exists bool) {
	if a.Description != nil {
		return *a.Description, true
	}
	return "", false
}

// SetDescription will overwrite whatever value is currently set for Description.
// Usage:
// a.SetDescription("")
func (a *project) SetDescription(value string) {
	copy := value
	a.Description = &copy

}

// GetURL Gets the value of URL and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetURL(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetURL() (returnValue string, exists bool) {
	if a.URL != nil {
		return *a.URL, true
	}
	return "", false
}

// SetURL will overwrite whatever value is currently set for URL.
// Usage:
// a.SetURL("")
func (a *project) SetURL(value string) {
	copy := value
	a.URL = &copy

}

// GetInceptionYear Gets the value of InceptionYear and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetInceptionYear(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetInceptionYear() (returnValue string, exists bool) {
	if a.InceptionYear != nil {
		return *a.InceptionYear, true
	}
	return "", false
}

// SetInceptionYear will overwrite whatever value is currently set for InceptionYear.
// Usage:
// a.SetInceptionYear("")
func (a *project) SetInceptionYear(value string) {
	copy := value
	a.InceptionYear = &copy

}

// GetOrganization Gets the value of Organization and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetOrganization(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetOrganization() (returnValue Organization, exists bool) {
	if a.Organization != nil {
		return *a.Organization, true
	}
	return Organization{}, false
}

// SetOrganization will overwrite whatever value is currently set for Organization.
// Usage:
// a.SetOrganization(Organization{})
func (a *project) SetOrganization(value Organization) {
	copy := value
	a.Organization = &copy

}

// GetLicenses Gets the value of Licenses and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetLicenses(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetLicenses() (returnValue SequenceLicense, exists bool) {
	if a.Licenses != nil {
		return *a.Licenses, true
	}
	return SequenceLicense{}, false
}

// SetLicenses will overwrite whatever value is currently set for Licenses.
// Usage:
// a.SetLicenses(SequenceLicense{})
func (a *project) SetLicenses(value SequenceLicense) {
	copy := value
	a.Licenses = &copy

}

// GetDevelopers Gets the value of Developers and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetDevelopers(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetDevelopers() (returnValue SequenceDeveloper, exists bool) {
	if a.Developers != nil {
		return *a.Developers, true
	}
	return SequenceDeveloper{}, false
}

// SetDevelopers will overwrite whatever value is currently set for Developers.
// Usage:
// a.SetDevelopers(SequenceDeveloper{})
func (a *project) SetDevelopers(value SequenceDeveloper) {
	copy := value
	a.Developers = &copy

}

// GetContributors Gets the value of Contributors and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetContributors(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetContributors() (returnValue SequenceContributor, exists bool) {
	if a.Contributors != nil {
		return *a.Contributors, true
	}
	return SequenceContributor{}, false
}

// SetContributors will overwrite whatever value is currently set for Contributors.
// Usage:
// a.SetContributors(SequenceContributor{})
func (a *project) SetContributors(value SequenceContributor) {
	copy := value
	a.Contributors = &copy

}

// GetMailingLists Gets the value of MailingLists and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetMailingLists(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetMailingLists() (returnValue SequenceMailingList, exists bool) {
	if a.MailingLists != nil {
		return *a.MailingLists, true
	}
	return SequenceMailingList{}, false
}

// SetMailingLists will overwrite whatever value is currently set for MailingLists.
// Usage:
// a.SetMailingLists(SequenceMailingList{})
func (a *project) SetMailingLists(value SequenceMailingList) {
	copy := value
	a.MailingLists = &copy

}

// GetPrerequisites Gets the value of Prerequisites and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetPrerequisites(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetPrerequisites() (returnValue Prerequisites, exists bool) {
	if a.Prerequisites != nil {
		return *a.Prerequisites, true
	}
	return Prerequisites{}, false
}

// SetPrerequisites will overwrite whatever value is currently set for Prerequisites.
// Usage:
// a.SetPrerequisites(Prerequisites{})
func (a *project) SetPrerequisites(value Prerequisites) {
	copy := value
	a.Prerequisites = &copy

}

// GetModules Gets the value of Modules and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetModules(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetModules() (returnValue SequenceModule, exists bool) {
	if a.Modules != nil {
		return *a.Modules, true
	}
	return SequenceModule{}, false
}

// SetModules will overwrite whatever value is currently set for Modules.
// Usage:
// a.SetModules(SequenceModule{})
func (a *project) SetModules(value SequenceModule) {
	copy := value
	a.Modules = &copy

}

// GetScm Gets the value of Scm and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetScm(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetScm() (returnValue Scm, exists bool) {
	if a.Scm != nil {
		return *a.Scm, true
	}
	return Scm{}, false
}

// SetScm will overwrite whatever value is currently set for Scm.
// Usage:
// a.SetScm(Scm{})
func (a *project) SetScm(value Scm) {
	copy := value
	a.Scm = &copy

}

// GetIssueManagement Gets the value of IssueManagement and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetIssueManagement(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetIssueManagement() (returnValue IssueManagement, exists bool) {
	if a.IssueManagement != nil {
		return *a.IssueManagement, true
	}
	return IssueManagement{}, false
}

// SetIssueManagement will overwrite whatever value is currently set for IssueManagement.
// Usage:
// a.SetIssueManagement(IssueManagement{})
func (a *project) SetIssueManagement(value IssueManagement) {
	copy := value
	a.IssueManagement = &copy

}

// GetCiManagement Gets the value of CiManagement and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetCiManagement(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetCiManagement() (returnValue CiManagement, exists bool) {
	if a.CiManagement != nil {
		return *a.CiManagement, true
	}
	return CiManagement{}, false
}

// SetCiManagement will overwrite whatever value is currently set for CiManagement.
// Usage:
// a.SetCiManagement(CiManagement{})
func (a *project) SetCiManagement(value CiManagement) {
	copy := value
	a.CiManagement = &copy

}

// GetDistributionManagement Gets the value of DistributionManagement and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetDistributionManagement(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetDistributionManagement() (returnValue DistributionManagement, exists bool) {
	if a.DistributionManagement != nil {
		return *a.DistributionManagement, true
	}
	return DistributionManagement{}, false
}

// SetDistributionManagement will overwrite whatever value is currently set for DistributionManagement.
// Usage:
// a.SetDistributionManagement(DistributionManagement{})
func (a *project) SetDistributionManagement(value DistributionManagement) {
	copy := value
	a.DistributionManagement = &copy

}

// GetProperties Gets the value of Properties and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetProperties(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetProperties() (returnValue XMLProperties, exists bool) {
	if a.Properties != nil {
		return *a.Properties, true
	}
	return XMLProperties{}, false
}

// SetProperties will overwrite whatever value is currently set for Properties.
// Usage:
// a.SetProperties(XMLProperties{})
func (a *project) SetProperties(value XMLProperties) {
	copy := value
	a.Properties = &copy

}

// GetDependencyManagement Gets the value of DependencyManagement and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetDependencyManagement(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetDependencyManagement() (returnValue DependencyManagement, exists bool) {
	if a.DependencyManagement != nil {
		return *a.DependencyManagement, true
	}
	return DependencyManagement{}, false
}

// SetDependencyManagement will overwrite whatever value is currently set for DependencyManagement.
// Usage:
// a.SetDependencyManagement(DependencyManagement{})
func (a *project) SetDependencyManagement(value DependencyManagement) {
	copy := value
	a.DependencyManagement = &copy

}

// GetDependencies Gets the value of Dependencies and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetDependencies(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetDependencies() (returnValue SequenceDependency, exists bool) {
	if a.Dependencies != nil {
		return *a.Dependencies, true
	}
	return SequenceDependency{}, false
}

// SetDependencies will overwrite whatever value is currently set for Dependencies.
// Usage:
// a.SetDependencies(SequenceDependency{})
func (a *project) SetDependencies(value SequenceDependency) {
	copy := value
	a.Dependencies = &copy

}

// GetRepositories Gets the value of Repositories and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetRepositories(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetRepositories() (returnValue SequenceRepository, exists bool) {
	if a.Repositories != nil {
		return *a.Repositories, true
	}
	return SequenceRepository{}, false
}

// SetRepositories will overwrite whatever value is currently set for Repositories.
// Usage:
// a.SetRepositories(SequenceRepository{})
func (a *project) SetRepositories(value SequenceRepository) {
	copy := value
	a.Repositories = &copy

}

// GetPluginRepositories Gets the value of PluginRepositories and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetPluginRepositories(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetPluginRepositories() (returnValue SequencePluginRepository, exists bool) {
	if a.PluginRepositories != nil {
		return *a.PluginRepositories, true
	}
	return SequencePluginRepository{}, false
}

// SetPluginRepositories will overwrite whatever value is currently set for PluginRepositories.
// Usage:
// a.SetPluginRepositories(SequencePluginRepository{})
func (a *project) SetPluginRepositories(value SequencePluginRepository) {
	copy := value
	a.PluginRepositories = &copy

}

// GetBuild Gets the value of Build and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetBuild(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetBuild() (returnValue Build, exists bool) {
	if a.Build != nil {
		return *a.Build, true
	}
	return Build{}, false
}

// SetBuild will overwrite whatever value is currently set for Build.
// Usage:
// a.SetBuild(Build{})
func (a *project) SetBuild(value Build) {
	copy := value
	a.Build = &copy

}

// GetReports Gets the value of Reports and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetReports(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetReports() (returnValue XMLInner, exists bool) {
	if a.Reports != nil {
		return *a.Reports, true
	}
	return XMLInner{}, false
}

// SetReports will overwrite whatever value is currently set for Reports.
// Usage:
// a.SetReports(XMLInner{})
func (a *project) SetReports(value XMLInner) {
	copy := value
	a.Reports = &copy

}

// GetReporting Gets the value of Reporting and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetReporting(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetReporting() (returnValue Reporting, exists bool) {
	if a.Reporting != nil {
		return *a.Reporting, true
	}
	return Reporting{}, false
}

// SetReporting will overwrite whatever value is currently set for Reporting.
// Usage:
// a.SetReporting(Reporting{})
func (a *project) SetReporting(value Reporting) {
	copy := value
	a.Reporting = &copy

}

// GetProfiles Gets the value of Profiles and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetProfiles(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetProfiles() (returnValue SequenceProfile, exists bool) {
	if a.Profiles != nil {
		return *a.Profiles, true
	}
	return SequenceProfile{}, false
}

// SetProfiles will overwrite whatever value is currently set for Profiles.
// Usage:
// a.SetProfiles(SequenceProfile{})
func (a *project) SetProfiles(value SequenceProfile) {
	copy := value
	a.Profiles = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *project) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *project) SetComment(value string) {
	a.Comment = value

}

// License Describes the licenses for this project. This is used to generate the license
//        page of the project's web site, as well as being taken into consideration in other reporting
//        and validation. The licenses listed for the project are that of the project itself, and not
//        of dependencies.
type License struct {

	/* Name The full legal name of the license.*/
	Name *string `xml:"name,omitempty"`

	/* Url The official url for the license text.*/
	URL *string `xml:"url,omitempty"`

	/* Distribution The primary method by which this project may be distributed.
	   <dl>
	     <dt>repo</dt>
	     <dd>may be downloaded from the Maven repository</dd>
	     <dt>manual</dt>
	     <dd>user must manually download and install the dependency.</dd>
	   </dl>*/
	Distribution *string `xml:"distribution,omitempty"`

	/* Comments Addendum information pertaining to this license.*/
	Comments *string `xml:"comments,omitempty"`

	Comment string `xml:",comment"`
}

// GetName Gets the value of Name and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetName(); ok {
//        fmt.Println(value)
//    }
func (a *License) GetName() (returnValue string, exists bool) {
	if a.Name != nil {
		return *a.Name, true
	}
	return "", false
}

// SetName will overwrite whatever value is currently set for Name.
// Usage:
// a.SetName("")
func (a *License) SetName(value string) {
	copy := value
	a.Name = &copy

}

// GetURL Gets the value of URL and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetURL(); ok {
//        fmt.Println(value)
//    }
func (a *License) GetURL() (returnValue string, exists bool) {
	if a.URL != nil {
		return *a.URL, true
	}
	return "", false
}

// SetURL will overwrite whatever value is currently set for URL.
// Usage:
// a.SetURL("")
func (a *License) SetURL(value string) {
	copy := value
	a.URL = &copy

}

// GetDistribution Gets the value of Distribution and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetDistribution(); ok {
//        fmt.Println(value)
//    }
func (a *License) GetDistribution() (returnValue string, exists bool) {
	if a.Distribution != nil {
		return *a.Distribution, true
	}
	return "", false
}

// SetDistribution will overwrite whatever value is currently set for Distribution.
// Usage:
// a.SetDistribution("")
func (a *License) SetDistribution(value string) {
	copy := value
	a.Distribution = &copy

}

// GetComments Gets the value of Comments and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComments(); ok {
//        fmt.Println(value)
//    }
func (a *License) GetComments() (returnValue string, exists bool) {
	if a.Comments != nil {
		return *a.Comments, true
	}
	return "", false
}

// SetComments will overwrite whatever value is currently set for Comments.
// Usage:
// a.SetComments("")
func (a *License) SetComments(value string) {
	copy := value
	a.Comments = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *License) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *License) SetComment(value string) {
	a.Comment = value

}

// SequenceNotifier contains the subelements for iterables in XML
type SequenceNotifier struct {
	Comment string `xml:",comment"`

	Notifier []*Notifier `xml:"notifier,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceNotifier) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequenceNotifier) SetComment(value string) {
	a.Comment = value

}

// GetNotifier Gets the value of Notifier and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetNotifier(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceNotifier) GetNotifier() (returnValue []*Notifier) {
	if a.Notifier != nil {
		return a.Notifier
	}
	return []*Notifier{}
}

// SetNotifier will overwrite whatever value is currently set for Notifier.
// Usage:
// a.SetNotifier(Notifier{})
func (a *SequenceNotifier) SetNotifier(value []*Notifier) {
	a.Notifier = value

}

// UpdateNotifier will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := Notifier{ }
// a.UpdateNotifier(value, 2)
func (a *SequenceNotifier) UpdateNotifier(value *Notifier, index int) {
	current := a.GetNotifier()
	if len(current) > index {
		a.Notifier[index] = value
	}
	a.Notifier = append(current, value)
}

// AddNotifier adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := Notifier{ }
// a.AddNotifier(value)
func (a *SequenceNotifier) AddNotifier(value *Notifier) {
	a.Notifier = append(a.Notifier, value)
}

// CiManagement The <code>&lt;CiManagement&gt;</code> element contains informations required to the
//        continuous integration system of the project.
type CiManagement struct {

	/* System The name of the continuous integration system, e.g. <code>continuum</code>.*/
	System *string `xml:"system,omitempty"`

	/* Url URL for the continuous integration system used by the project if it has a web
	   interface.*/
	URL *string `xml:"url,omitempty"`

	/* Notifiers Configuration for notifying developers/users when a build is unsuccessful,
	   including user information and notification mode.*/
	Notifiers *SequenceNotifier `xml:"notifiers,omitempty"`

	Comment string `xml:",comment"`
}

// GetSystem Gets the value of System and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetSystem(); ok {
//        fmt.Println(value)
//    }
func (a *CiManagement) GetSystem() (returnValue string, exists bool) {
	if a.System != nil {
		return *a.System, true
	}
	return "", false
}

// SetSystem will overwrite whatever value is currently set for System.
// Usage:
// a.SetSystem("")
func (a *CiManagement) SetSystem(value string) {
	copy := value
	a.System = &copy

}

// GetURL Gets the value of URL and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetURL(); ok {
//        fmt.Println(value)
//    }
func (a *CiManagement) GetURL() (returnValue string, exists bool) {
	if a.URL != nil {
		return *a.URL, true
	}
	return "", false
}

// SetURL will overwrite whatever value is currently set for URL.
// Usage:
// a.SetURL("")
func (a *CiManagement) SetURL(value string) {
	copy := value
	a.URL = &copy

}

// GetNotifiers Gets the value of Notifiers and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetNotifiers(); ok {
//        fmt.Println(value)
//    }
func (a *CiManagement) GetNotifiers() (returnValue SequenceNotifier, exists bool) {
	if a.Notifiers != nil {
		return *a.Notifiers, true
	}
	return SequenceNotifier{}, false
}

// SetNotifiers will overwrite whatever value is currently set for Notifiers.
// Usage:
// a.SetNotifiers(SequenceNotifier{})
func (a *CiManagement) SetNotifiers(value SequenceNotifier) {
	copy := value
	a.Notifiers = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *CiManagement) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *CiManagement) SetComment(value string) {
	a.Comment = value

}

// Notifier Configures one method for notifying users/developers when a build breaks.
type Notifier struct {

	/* Type The mechanism used to deliver notifications.*/
	Type *string `xml:"type,omitempty"`

	/* SendOnError Whether to send notifications on error.*/
	SendOnError *bool `xml:"sendOnError,omitempty"`

	/* SendOnFailure Whether to send notifications on failure.*/
	SendOnFailure *bool `xml:"sendOnFailure,omitempty"`

	/* SendOnSuccess Whether to send notifications on success.*/
	SendOnSuccess *bool `xml:"sendOnSuccess,omitempty"`

	/* SendOnWarning Whether to send notifications on warning.*/
	SendOnWarning *bool `xml:"sendOnWarning,omitempty"`

	/* Address <b>Deprecated</b>. Where to send the notification to - eg email address.*/
	Address *string `xml:"address,omitempty"`

	/* Configuration Extended configuration specific to this notifier goes here.*/
	Configuration *XMLInner `xml:"configuration,omitempty"`

	Comment string `xml:",comment"`
}

// GetType Gets the value of Type and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetType(); ok {
//        fmt.Println(value)
//    }
func (a *Notifier) GetType() (returnValue string, exists bool) {
	if a.Type != nil {
		return *a.Type, true
	}
	return "", false
}

// SetType will overwrite whatever value is currently set for Type.
// Usage:
// a.SetType("")
func (a *Notifier) SetType(value string) {
	copy := value
	a.Type = &copy

}

// GetSendOnError Gets the value of SendOnError and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetSendOnError(); ok {
//        fmt.Println(value)
//    }
func (a *Notifier) GetSendOnError() (returnValue bool, exists bool) {
	if a.SendOnError != nil {
		return *a.SendOnError, true
	}
	return false, false
}

// SetSendOnError will overwrite whatever value is currently set for SendOnError.
// Usage:
// a.SetSendOnError(false)
func (a *Notifier) SetSendOnError(value bool) {
	copy := value
	a.SendOnError = &copy

}

// GetSendOnFailure Gets the value of SendOnFailure and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetSendOnFailure(); ok {
//        fmt.Println(value)
//    }
func (a *Notifier) GetSendOnFailure() (returnValue bool, exists bool) {
	if a.SendOnFailure != nil {
		return *a.SendOnFailure, true
	}
	return false, false
}

// SetSendOnFailure will overwrite whatever value is currently set for SendOnFailure.
// Usage:
// a.SetSendOnFailure(false)
func (a *Notifier) SetSendOnFailure(value bool) {
	copy := value
	a.SendOnFailure = &copy

}

// GetSendOnSuccess Gets the value of SendOnSuccess and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetSendOnSuccess(); ok {
//        fmt.Println(value)
//    }
func (a *Notifier) GetSendOnSuccess() (returnValue bool, exists bool) {
	if a.SendOnSuccess != nil {
		return *a.SendOnSuccess, true
	}
	return false, false
}

// SetSendOnSuccess will overwrite whatever value is currently set for SendOnSuccess.
// Usage:
// a.SetSendOnSuccess(false)
func (a *Notifier) SetSendOnSuccess(value bool) {
	copy := value
	a.SendOnSuccess = &copy

}

// GetSendOnWarning Gets the value of SendOnWarning and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetSendOnWarning(); ok {
//        fmt.Println(value)
//    }
func (a *Notifier) GetSendOnWarning() (returnValue bool, exists bool) {
	if a.SendOnWarning != nil {
		return *a.SendOnWarning, true
	}
	return false, false
}

// SetSendOnWarning will overwrite whatever value is currently set for SendOnWarning.
// Usage:
// a.SetSendOnWarning(false)
func (a *Notifier) SetSendOnWarning(value bool) {
	copy := value
	a.SendOnWarning = &copy

}

// GetAddress Gets the value of Address and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetAddress(); ok {
//        fmt.Println(value)
//    }
func (a *Notifier) GetAddress() (returnValue string, exists bool) {
	if a.Address != nil {
		return *a.Address, true
	}
	return "", false
}

// SetAddress will overwrite whatever value is currently set for Address.
// Usage:
// a.SetAddress("")
func (a *Notifier) SetAddress(value string) {
	copy := value
	a.Address = &copy

}

// GetConfiguration Gets the value of Configuration and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetConfiguration(); ok {
//        fmt.Println(value)
//    }
func (a *Notifier) GetConfiguration() (returnValue XMLInner, exists bool) {
	if a.Configuration != nil {
		return *a.Configuration, true
	}
	return XMLInner{}, false
}

// SetConfiguration will overwrite whatever value is currently set for Configuration.
// Usage:
// a.SetConfiguration(XMLInner{})
func (a *Notifier) SetConfiguration(value XMLInner) {
	copy := value
	a.Configuration = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *Notifier) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *Notifier) SetComment(value string) {
	a.Comment = value

}

// Scm The <code>&lt;scm&gt;</code> element contains informations required to the SCM
//        (Source Control Management) of the project.
type Scm struct {

	/* Connection The source control management system URL
	   that describes the repository and how to connect to the
	   repository. For more information, see the
	   <a href="https://maven.apache.org/scm/scm-url-format.html">URL format</a>
	   and <a href="https://maven.apache.org/scm/scms-overview.html">list of supported SCMs</a>.
	   This connection is read-only.
	   <br><b>Default value is</b>: parent value [+ path adjustment] + (artifactId or project.directory property), or just parent value if
	   scm's <code>child.scm.connection.inherit.append.path="false"</code>*/
	Connection *string `xml:"connection,omitempty"`

	/* DeveloperConnection Just like <code>connection</code>, but for developers, i.e. this scm connection
	   will not be read only.
	   <br><b>Default value is</b>: parent value [+ path adjustment] + (artifactId or project.directory property), or just parent value if
	   scm's <code>child.scm.developerConnection.inherit.append.path="false"</code>*/
	DeveloperConnection *string `xml:"developerConnection,omitempty"`

	/* Tag The tag of current code. By default, it's set to HEAD during development.*/
	Tag *string `xml:"tag,omitempty"`

	/* Url The URL to the project's browsable SCM repository, such as ViewVC or Fisheye.
	   <br><b>Default value is</b>: parent value [+ path adjustment] + (artifactId or project.directory property), or just parent value if
	   scm's <code>child.scm.url.inherit.append.path="false"</code>*/
	URL *string `xml:"url,omitempty"`

	Comment string `xml:",comment"`
}

// GetConnection Gets the value of Connection and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetConnection(); ok {
//        fmt.Println(value)
//    }
func (a *Scm) GetConnection() (returnValue string, exists bool) {
	if a.Connection != nil {
		return *a.Connection, true
	}
	return "", false
}

// SetConnection will overwrite whatever value is currently set for Connection.
// Usage:
// a.SetConnection("")
func (a *Scm) SetConnection(value string) {
	copy := value
	a.Connection = &copy

}

// GetDeveloperConnection Gets the value of DeveloperConnection and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetDeveloperConnection(); ok {
//        fmt.Println(value)
//    }
func (a *Scm) GetDeveloperConnection() (returnValue string, exists bool) {
	if a.DeveloperConnection != nil {
		return *a.DeveloperConnection, true
	}
	return "", false
}

// SetDeveloperConnection will overwrite whatever value is currently set for DeveloperConnection.
// Usage:
// a.SetDeveloperConnection("")
func (a *Scm) SetDeveloperConnection(value string) {
	copy := value
	a.DeveloperConnection = &copy

}

// GetTag Gets the value of Tag and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetTag(); ok {
//        fmt.Println(value)
//    }
func (a *Scm) GetTag() (returnValue string, exists bool) {
	if a.Tag != nil {
		return *a.Tag, true
	}
	return "", false
}

// SetTag will overwrite whatever value is currently set for Tag.
// Usage:
// a.SetTag("")
func (a *Scm) SetTag(value string) {
	copy := value
	a.Tag = &copy

}

// GetURL Gets the value of URL and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetURL(); ok {
//        fmt.Println(value)
//    }
func (a *Scm) GetURL() (returnValue string, exists bool) {
	if a.URL != nil {
		return *a.URL, true
	}
	return "", false
}

// SetURL will overwrite whatever value is currently set for URL.
// Usage:
// a.SetURL("")
func (a *Scm) SetURL(value string) {
	copy := value
	a.URL = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *Scm) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *Scm) SetComment(value string) {
	a.Comment = value

}

// IssueManagement Information about the issue tracking (or bug tracking) system used to manage this
//        project.
type IssueManagement struct {

	/* System The name of the issue management system, e.g. Bugzilla*/
	System *string `xml:"system,omitempty"`

	/* Url URL for the issue management system used by the project.*/
	URL *string `xml:"url,omitempty"`

	Comment string `xml:",comment"`
}

// GetSystem Gets the value of System and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetSystem(); ok {
//        fmt.Println(value)
//    }
func (a *IssueManagement) GetSystem() (returnValue string, exists bool) {
	if a.System != nil {
		return *a.System, true
	}
	return "", false
}

// SetSystem will overwrite whatever value is currently set for System.
// Usage:
// a.SetSystem("")
func (a *IssueManagement) SetSystem(value string) {
	copy := value
	a.System = &copy

}

// GetURL Gets the value of URL and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetURL(); ok {
//        fmt.Println(value)
//    }
func (a *IssueManagement) GetURL() (returnValue string, exists bool) {
	if a.URL != nil {
		return *a.URL, true
	}
	return "", false
}

// SetURL will overwrite whatever value is currently set for URL.
// Usage:
// a.SetURL("")
func (a *IssueManagement) SetURL(value string) {
	copy := value
	a.URL = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *IssueManagement) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *IssueManagement) SetComment(value string) {
	a.Comment = value

}

// DependencyManagement Section for management of default dependency information for use in a group of
//        POMs.
type DependencyManagement struct {

	/* Dependencies The dependencies specified here are not used until they are referenced in a
	   POM within the group. This allows the specification of a "standard" version for a
	   particular dependency.*/
	Dependencies *SequenceDependency `xml:"dependencies,omitempty"`

	Comment string `xml:",comment"`
}

// GetDependencies Gets the value of Dependencies and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetDependencies(); ok {
//        fmt.Println(value)
//    }
func (a *DependencyManagement) GetDependencies() (returnValue SequenceDependency, exists bool) {
	if a.Dependencies != nil {
		return *a.Dependencies, true
	}
	return SequenceDependency{}, false
}

// SetDependencies will overwrite whatever value is currently set for Dependencies.
// Usage:
// a.SetDependencies(SequenceDependency{})
func (a *DependencyManagement) SetDependencies(value SequenceDependency) {
	copy := value
	a.Dependencies = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *DependencyManagement) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *DependencyManagement) SetComment(value string) {
	a.Comment = value

}

// SequenceExclusion contains the subelements for iterables in XML
type SequenceExclusion struct {
	Comment string `xml:",comment"`

	Exclusion []*Exclusion `xml:"exclusion,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceExclusion) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequenceExclusion) SetComment(value string) {
	a.Comment = value

}

// GetExclusion Gets the value of Exclusion and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetExclusion(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceExclusion) GetExclusion() (returnValue []*Exclusion) {
	if a.Exclusion != nil {
		return a.Exclusion
	}
	return []*Exclusion{}
}

// SetExclusion will overwrite whatever value is currently set for Exclusion.
// Usage:
// a.SetExclusion(Exclusion{})
func (a *SequenceExclusion) SetExclusion(value []*Exclusion) {
	a.Exclusion = value

}

// UpdateExclusion will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := Exclusion{ }
// a.UpdateExclusion(value, 2)
func (a *SequenceExclusion) UpdateExclusion(value *Exclusion, index int) {
	current := a.GetExclusion()
	if len(current) > index {
		a.Exclusion[index] = value
	}
	a.Exclusion = append(current, value)
}

// AddExclusion adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := Exclusion{ }
// a.AddExclusion(value)
func (a *SequenceExclusion) AddExclusion(value *Exclusion) {
	a.Exclusion = append(a.Exclusion, value)
}

// Dependency The <code>&lt;dependency&gt;</code> element contains information about a dependency
//        of the project.
type Dependency struct {

	/* GroupId The project group that produced the dependency, e.g.
	   <code>org.apache.maven</code>.*/
	GroupID *string `xml:"groupId,omitempty"`

	/* ArtifactId The unique id for an artifact produced by the project group, e.g.
	   <code>maven-artifact</code>.*/
	ArtifactID *string `xml:"artifactId,omitempty"`

	/* Version The version of the dependency, e.g. <code>3.2.1</code>. In Maven 2, this can also be
	   specified as a range of versions.*/
	Version *string `xml:"version,omitempty"`

	/* Type The type of dependency. While it
	   usually represents the extension on the filename of the dependency,
	   that is not always the case. A type can be mapped to a different
	   extension and a classifier.
	   The type often corresponds to the packaging used, though this is also
	   not always the case.
	   Some examples are <code>jar</code>, <code>war</code>, <code>ejb-client</code>
	   and <code>test-jar</code>: see <a href="../maven-core/artifact-handlers.html">default
	   artifact handlers</a> for a list.
	   New types can be defined by plugins that set
	   <code>extensions</code> to <code>true</code>, so this is not a complete list.*/
	Type *string `xml:"type,omitempty"`

	/* Classifier The classifier of the dependency. It is appended to
	   the filename after the version. This allows:
	   <ul>
	   <li>referring to attached artifact, for example <code>sources</code> and <code>javadoc</code>:
	   see <a href="../maven-core/artifact-handlers.html">default artifact handlers</a> for a list,</li>
	   <li>distinguishing two artifacts
	   that belong to the same POM but were built differently.
	   For example, <code>jdk14</code> and <code>jdk15</code>.</li>
	   </ul>*/
	Classifier *string `xml:"classifier,omitempty"`

	/* Scope The scope of the dependency - <code>compile</code>, <code>runtime</code>,
	   <code>test</code>, <code>system</code>, and <code>provided</code>. Used to
	   calculate the various classpaths used for compilation, testing, and so on.
	   It also assists in determining which artifacts to include in a distribution of
	   this project. For more information, see
	   <a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">the
	   dependency mechanism</a>. The default scope is <code>compile</code>.*/
	Scope *string `xml:"scope,omitempty"`

	/* SystemPath FOR SYSTEM SCOPE ONLY. Note that use of this property is <b>discouraged</b>
	   and may be replaced in later versions. This specifies the path on the filesystem
	   for this dependency.
	   Requires an absolute path for the value, not relative.
	   Use a property that gives the machine specific absolute path,
	   e.g. <code>${java.home}</code>.*/
	SystemPath *string `xml:"systemPath,omitempty"`

	/* Exclusions Lists a set of artifacts that should be excluded from this dependency's
	   artifact list when it comes to calculating transitive dependencies.*/
	Exclusions *SequenceExclusion `xml:"exclusions,omitempty"`

	/* Optional Indicates the dependency is optional for use of this library. While the
	   version of the dependency will be taken into account for dependency calculation if the
	   library is used elsewhere, it will not be passed on transitively. Note: While the type
	   of this field is <code>String</code> for technical reasons, the semantic type is actually
	   <code>Boolean</code>. Default value is <code>false</code>.*/
	Optional *string `xml:"optional,omitempty"`

	Comment string `xml:",comment"`
}

// GetGroupID Gets the value of GroupID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetGroupID(); ok {
//        fmt.Println(value)
//    }
func (a *Dependency) GetGroupID() (returnValue string, exists bool) {
	if a.GroupID != nil {
		return *a.GroupID, true
	}
	return "", false
}

// SetGroupID will overwrite whatever value is currently set for GroupID.
// Usage:
// a.SetGroupID("")
func (a *Dependency) SetGroupID(value string) {
	copy := value
	a.GroupID = &copy

}

// GetArtifactID Gets the value of ArtifactID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetArtifactID(); ok {
//        fmt.Println(value)
//    }
func (a *Dependency) GetArtifactID() (returnValue string, exists bool) {
	if a.ArtifactID != nil {
		return *a.ArtifactID, true
	}
	return "", false
}

// SetArtifactID will overwrite whatever value is currently set for ArtifactID.
// Usage:
// a.SetArtifactID("")
func (a *Dependency) SetArtifactID(value string) {
	copy := value
	a.ArtifactID = &copy

}

// GetVersion Gets the value of Version and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetVersion(); ok {
//        fmt.Println(value)
//    }
func (a *Dependency) GetVersion() (returnValue string, exists bool) {
	if a.Version != nil {
		return *a.Version, true
	}
	return "", false
}

// SetVersion will overwrite whatever value is currently set for Version.
// Usage:
// a.SetVersion("")
func (a *Dependency) SetVersion(value string) {
	copy := value
	a.Version = &copy

}

// GetType Gets the value of Type and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetType(); ok {
//        fmt.Println(value)
//    }
func (a *Dependency) GetType() (returnValue string, exists bool) {
	if a.Type != nil {
		return *a.Type, true
	}
	return "", false
}

// SetType will overwrite whatever value is currently set for Type.
// Usage:
// a.SetType("")
func (a *Dependency) SetType(value string) {
	copy := value
	a.Type = &copy

}

// GetClassifier Gets the value of Classifier and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetClassifier(); ok {
//        fmt.Println(value)
//    }
func (a *Dependency) GetClassifier() (returnValue string, exists bool) {
	if a.Classifier != nil {
		return *a.Classifier, true
	}
	return "", false
}

// SetClassifier will overwrite whatever value is currently set for Classifier.
// Usage:
// a.SetClassifier("")
func (a *Dependency) SetClassifier(value string) {
	copy := value
	a.Classifier = &copy

}

// GetScope Gets the value of Scope and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetScope(); ok {
//        fmt.Println(value)
//    }
func (a *Dependency) GetScope() (returnValue string, exists bool) {
	if a.Scope != nil {
		return *a.Scope, true
	}
	return "", false
}

// SetScope will overwrite whatever value is currently set for Scope.
// Usage:
// a.SetScope("")
func (a *Dependency) SetScope(value string) {
	copy := value
	a.Scope = &copy

}

// GetSystemPath Gets the value of SystemPath and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetSystemPath(); ok {
//        fmt.Println(value)
//    }
func (a *Dependency) GetSystemPath() (returnValue string, exists bool) {
	if a.SystemPath != nil {
		return *a.SystemPath, true
	}
	return "", false
}

// SetSystemPath will overwrite whatever value is currently set for SystemPath.
// Usage:
// a.SetSystemPath("")
func (a *Dependency) SetSystemPath(value string) {
	copy := value
	a.SystemPath = &copy

}

// GetExclusions Gets the value of Exclusions and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetExclusions(); ok {
//        fmt.Println(value)
//    }
func (a *Dependency) GetExclusions() (returnValue SequenceExclusion, exists bool) {
	if a.Exclusions != nil {
		return *a.Exclusions, true
	}
	return SequenceExclusion{}, false
}

// SetExclusions will overwrite whatever value is currently set for Exclusions.
// Usage:
// a.SetExclusions(SequenceExclusion{})
func (a *Dependency) SetExclusions(value SequenceExclusion) {
	copy := value
	a.Exclusions = &copy

}

// GetOptional Gets the value of Optional and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetOptional(); ok {
//        fmt.Println(value)
//    }
func (a *Dependency) GetOptional() (returnValue string, exists bool) {
	if a.Optional != nil {
		return *a.Optional, true
	}
	return "", false
}

// SetOptional will overwrite whatever value is currently set for Optional.
// Usage:
// a.SetOptional("")
func (a *Dependency) SetOptional(value string) {
	copy := value
	a.Optional = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *Dependency) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *Dependency) SetComment(value string) {
	a.Comment = value

}

// Exclusion The <code>&lt;exclusion&gt;</code> element contains informations required to exclude
//        an artifact to the project.
type Exclusion struct {

	/* ArtifactId The artifact ID of the project to exclude.*/
	ArtifactID *string `xml:"artifactId,omitempty"`

	/* GroupId The group ID of the project to exclude.*/
	GroupID *string `xml:"groupId,omitempty"`

	Comment string `xml:",comment"`
}

// GetArtifactID Gets the value of ArtifactID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetArtifactID(); ok {
//        fmt.Println(value)
//    }
func (a *Exclusion) GetArtifactID() (returnValue string, exists bool) {
	if a.ArtifactID != nil {
		return *a.ArtifactID, true
	}
	return "", false
}

// SetArtifactID will overwrite whatever value is currently set for ArtifactID.
// Usage:
// a.SetArtifactID("")
func (a *Exclusion) SetArtifactID(value string) {
	copy := value
	a.ArtifactID = &copy

}

// GetGroupID Gets the value of GroupID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetGroupID(); ok {
//        fmt.Println(value)
//    }
func (a *Exclusion) GetGroupID() (returnValue string, exists bool) {
	if a.GroupID != nil {
		return *a.GroupID, true
	}
	return "", false
}

// SetGroupID will overwrite whatever value is currently set for GroupID.
// Usage:
// a.SetGroupID("")
func (a *Exclusion) SetGroupID(value string) {
	copy := value
	a.GroupID = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *Exclusion) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *Exclusion) SetComment(value string) {
	a.Comment = value

}

// Parent The <code>&lt;parent&gt;</code> element contains information required to locate the parent project from which
//        this project will inherit from.
//        <strong>Note:</strong> The children of this element are not interpolated and must be given as literal values.
type Parent struct {

	/* GroupId The group id of the parent project to inherit from.*/
	GroupID *string `xml:"groupId,omitempty"`

	/* ArtifactId The artifact id of the parent project to inherit from.*/
	ArtifactID *string `xml:"artifactId,omitempty"`

	/* Version The version of the parent project to inherit.*/
	Version *string `xml:"version,omitempty"`

	/* RelativePath The relative path of the parent <code>pom.xml</code> file within the check out.
	   If not specified, it defaults to <code>../pom.xml</code>.
	   Maven looks for the parent POM first in this location on
	   the filesystem, then the local repository, and lastly in the remote repo.
	   <code>relativePath</code> allows you to select a different location,
	   for example when your structure is flat, or deeper without an intermediate parent POM.
	   However, the group ID, artifact ID and version are still required,
	   and must match the file in the location given or it will revert to the repository for the POM.
	   This feature is only for enhancing the development in a local checkout of that project.
	   Set the value to an empty string in case you want to disable the feature and always resolve
	   the parent POM from the repositories.*/
	RelativePath *string `xml:"relativePath,omitempty"`

	Comment string `xml:",comment"`
}

// GetGroupID Gets the value of GroupID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetGroupID(); ok {
//        fmt.Println(value)
//    }
func (a *Parent) GetGroupID() (returnValue string, exists bool) {
	if a.GroupID != nil {
		return *a.GroupID, true
	}
	return "", false
}

// SetGroupID will overwrite whatever value is currently set for GroupID.
// Usage:
// a.SetGroupID("")
func (a *Parent) SetGroupID(value string) {
	copy := value
	a.GroupID = &copy

}

// GetArtifactID Gets the value of ArtifactID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetArtifactID(); ok {
//        fmt.Println(value)
//    }
func (a *Parent) GetArtifactID() (returnValue string, exists bool) {
	if a.ArtifactID != nil {
		return *a.ArtifactID, true
	}
	return "", false
}

// SetArtifactID will overwrite whatever value is currently set for ArtifactID.
// Usage:
// a.SetArtifactID("")
func (a *Parent) SetArtifactID(value string) {
	copy := value
	a.ArtifactID = &copy

}

// GetVersion Gets the value of Version and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetVersion(); ok {
//        fmt.Println(value)
//    }
func (a *Parent) GetVersion() (returnValue string, exists bool) {
	if a.Version != nil {
		return *a.Version, true
	}
	return "", false
}

// SetVersion will overwrite whatever value is currently set for Version.
// Usage:
// a.SetVersion("")
func (a *Parent) SetVersion(value string) {
	copy := value
	a.Version = &copy

}

// GetRelativePath Gets the value of RelativePath and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetRelativePath(); ok {
//        fmt.Println(value)
//    }
func (a *Parent) GetRelativePath() (returnValue string, exists bool) {
	if a.RelativePath != nil {
		return *a.RelativePath, true
	}
	return "", false
}

// SetRelativePath will overwrite whatever value is currently set for RelativePath.
// Usage:
// a.SetRelativePath("")
func (a *Parent) SetRelativePath(value string) {
	copy := value
	a.RelativePath = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *Parent) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *Parent) SetComment(value string) {
	a.Comment = value

}

// SequenceRole contains the subelements for iterables in XML
type SequenceRole struct {
	Comment string `xml:",comment"`

	Role []*string `xml:"role,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceRole) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequenceRole) SetComment(value string) {
	a.Comment = value

}

// GetRole Gets the value of Role and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetRole(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceRole) GetRole() (returnValue []*string) {
	if a.Role != nil {
		return a.Role
	}
	return []*string{}
}

// SetRole will overwrite whatever value is currently set for Role.
// Usage:
// a.SetRole(string{})
func (a *SequenceRole) SetRole(value []*string) {
	a.Role = value

}

// UpdateRole will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := string{ }
// a.UpdateRole(value, 2)
func (a *SequenceRole) UpdateRole(value *string, index int) {
	current := a.GetRole()
	if len(current) > index {
		a.Role[index] = value
	}
	a.Role = append(current, value)
}

// AddRole adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := string{ }
// a.AddRole(value)
func (a *SequenceRole) AddRole(value *string) {
	a.Role = append(a.Role, value)
}

// Developer Information about one of the committers on this project.
type Developer struct {

	/* Id The unique ID of the developer in the SCM.*/
	ID *string `xml:"id,omitempty"`

	/* Name The full name of the contributor.*/
	Name *string `xml:"name,omitempty"`

	/* Email The email address of the contributor.*/
	Email *string `xml:"email,omitempty"`

	/* Url The URL for the homepage of the contributor.*/
	URL *string `xml:"url,omitempty"`

	/* Organization The organization to which the contributor belongs.*/
	Organization *string `xml:"organization,omitempty"`

	/* OrganizationUrl The URL of the organization.*/
	OrganizationURL *string `xml:"organizationUrl,omitempty"`

	/* Roles The roles the contributor plays in the project. Each role is described by a
	   <code>role</code> element, the body of which is a role name. This can also be used to
	   describe the contribution.*/
	Roles *SequenceRole `xml:"roles,omitempty"`

	/* Timezone The timezone the contributor is in. Typically, this is a number in the range
	   <a href="http://en.wikipedia.org/wiki/UTC%E2%88%9212:00">-12</a> to <a href="http://en.wikipedia.org/wiki/UTC%2B14:00">+14</a>
	   or a valid time zone id like "America/Montreal" (UTC-05:00) or "Europe/Paris" (UTC+01:00).*/
	Timezone *string `xml:"timezone,omitempty"`

	/* Properties Properties about the contributor, such as an instant messenger handle.*/
	Properties *XMLProperties `xml:"properties,omitempty"`

	Comment string `xml:",comment"`
}

// GetID Gets the value of ID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetID(); ok {
//        fmt.Println(value)
//    }
func (a *Developer) GetID() (returnValue string, exists bool) {
	if a.ID != nil {
		return *a.ID, true
	}
	return "", false
}

// SetID will overwrite whatever value is currently set for ID.
// Usage:
// a.SetID("")
func (a *Developer) SetID(value string) {
	copy := value
	a.ID = &copy

}

// GetName Gets the value of Name and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetName(); ok {
//        fmt.Println(value)
//    }
func (a *Developer) GetName() (returnValue string, exists bool) {
	if a.Name != nil {
		return *a.Name, true
	}
	return "", false
}

// SetName will overwrite whatever value is currently set for Name.
// Usage:
// a.SetName("")
func (a *Developer) SetName(value string) {
	copy := value
	a.Name = &copy

}

// GetEmail Gets the value of Email and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetEmail(); ok {
//        fmt.Println(value)
//    }
func (a *Developer) GetEmail() (returnValue string, exists bool) {
	if a.Email != nil {
		return *a.Email, true
	}
	return "", false
}

// SetEmail will overwrite whatever value is currently set for Email.
// Usage:
// a.SetEmail("")
func (a *Developer) SetEmail(value string) {
	copy := value
	a.Email = &copy

}

// GetURL Gets the value of URL and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetURL(); ok {
//        fmt.Println(value)
//    }
func (a *Developer) GetURL() (returnValue string, exists bool) {
	if a.URL != nil {
		return *a.URL, true
	}
	return "", false
}

// SetURL will overwrite whatever value is currently set for URL.
// Usage:
// a.SetURL("")
func (a *Developer) SetURL(value string) {
	copy := value
	a.URL = &copy

}

// GetOrganization Gets the value of Organization and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetOrganization(); ok {
//        fmt.Println(value)
//    }
func (a *Developer) GetOrganization() (returnValue string, exists bool) {
	if a.Organization != nil {
		return *a.Organization, true
	}
	return "", false
}

// SetOrganization will overwrite whatever value is currently set for Organization.
// Usage:
// a.SetOrganization("")
func (a *Developer) SetOrganization(value string) {
	copy := value
	a.Organization = &copy

}

// GetOrganizationURL Gets the value of OrganizationURL and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetOrganizationURL(); ok {
//        fmt.Println(value)
//    }
func (a *Developer) GetOrganizationURL() (returnValue string, exists bool) {
	if a.OrganizationURL != nil {
		return *a.OrganizationURL, true
	}
	return "", false
}

// SetOrganizationURL will overwrite whatever value is currently set for OrganizationURL.
// Usage:
// a.SetOrganizationURL("")
func (a *Developer) SetOrganizationURL(value string) {
	copy := value
	a.OrganizationURL = &copy

}

// GetRoles Gets the value of Roles and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetRoles(); ok {
//        fmt.Println(value)
//    }
func (a *Developer) GetRoles() (returnValue SequenceRole, exists bool) {
	if a.Roles != nil {
		return *a.Roles, true
	}
	return SequenceRole{}, false
}

// SetRoles will overwrite whatever value is currently set for Roles.
// Usage:
// a.SetRoles(SequenceRole{})
func (a *Developer) SetRoles(value SequenceRole) {
	copy := value
	a.Roles = &copy

}

// GetTimezone Gets the value of Timezone and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetTimezone(); ok {
//        fmt.Println(value)
//    }
func (a *Developer) GetTimezone() (returnValue string, exists bool) {
	if a.Timezone != nil {
		return *a.Timezone, true
	}
	return "", false
}

// SetTimezone will overwrite whatever value is currently set for Timezone.
// Usage:
// a.SetTimezone("")
func (a *Developer) SetTimezone(value string) {
	copy := value
	a.Timezone = &copy

}

// GetProperties Gets the value of Properties and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetProperties(); ok {
//        fmt.Println(value)
//    }
func (a *Developer) GetProperties() (returnValue XMLProperties, exists bool) {
	if a.Properties != nil {
		return *a.Properties, true
	}
	return XMLProperties{}, false
}

// SetProperties will overwrite whatever value is currently set for Properties.
// Usage:
// a.SetProperties(XMLProperties{})
func (a *Developer) SetProperties(value XMLProperties) {
	copy := value
	a.Properties = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *Developer) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *Developer) SetComment(value string) {
	a.Comment = value

}

// SequenceOtherArchive contains the subelements for iterables in XML
type SequenceOtherArchive struct {
	Comment string `xml:",comment"`

	OtherArchive []*string `xml:"otherArchive,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceOtherArchive) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequenceOtherArchive) SetComment(value string) {
	a.Comment = value

}

// GetOtherArchive Gets the value of OtherArchive and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetOtherArchive(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceOtherArchive) GetOtherArchive() (returnValue []*string) {
	if a.OtherArchive != nil {
		return a.OtherArchive
	}
	return []*string{}
}

// SetOtherArchive will overwrite whatever value is currently set for OtherArchive.
// Usage:
// a.SetOtherArchive(string{})
func (a *SequenceOtherArchive) SetOtherArchive(value []*string) {
	a.OtherArchive = value

}

// UpdateOtherArchive will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := string{ }
// a.UpdateOtherArchive(value, 2)
func (a *SequenceOtherArchive) UpdateOtherArchive(value *string, index int) {
	current := a.GetOtherArchive()
	if len(current) > index {
		a.OtherArchive[index] = value
	}
	a.OtherArchive = append(current, value)
}

// AddOtherArchive adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := string{ }
// a.AddOtherArchive(value)
func (a *SequenceOtherArchive) AddOtherArchive(value *string) {
	a.OtherArchive = append(a.OtherArchive, value)
}

// MailingList This element describes all of the mailing lists associated with a project. The
//        auto-generated site references this information.
type MailingList struct {

	/* Name The name of the mailing list.*/
	Name *string `xml:"name,omitempty"`

	/* Subscribe The email address or link that can be used to subscribe to
	   the mailing list.  If this is an email address, a
	   <code>mailto:</code> link will automatically be created
	   when the documentation is created.*/
	Subscribe *string `xml:"subscribe,omitempty"`

	/* Unsubscribe The email address or link that can be used to unsubscribe to
	   the mailing list.  If this is an email address, a
	   <code>mailto:</code> link will automatically be created
	   when the documentation is created.*/
	Unsubscribe *string `xml:"unsubscribe,omitempty"`

	/* Post The email address or link that can be used to post to
	   the mailing list.  If this is an email address, a
	   <code>mailto:</code> link will automatically be created
	   when the documentation is created.*/
	Post *string `xml:"post,omitempty"`

	/* Archive The link to a URL where you can browse the mailing list archive.*/
	Archive *string `xml:"archive,omitempty"`

	/* OtherArchives The link to alternate URLs where you can browse the list archive.*/
	OtherArchives *SequenceOtherArchive `xml:"otherArchives,omitempty"`

	Comment string `xml:",comment"`
}

// GetName Gets the value of Name and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetName(); ok {
//        fmt.Println(value)
//    }
func (a *MailingList) GetName() (returnValue string, exists bool) {
	if a.Name != nil {
		return *a.Name, true
	}
	return "", false
}

// SetName will overwrite whatever value is currently set for Name.
// Usage:
// a.SetName("")
func (a *MailingList) SetName(value string) {
	copy := value
	a.Name = &copy

}

// GetSubscribe Gets the value of Subscribe and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetSubscribe(); ok {
//        fmt.Println(value)
//    }
func (a *MailingList) GetSubscribe() (returnValue string, exists bool) {
	if a.Subscribe != nil {
		return *a.Subscribe, true
	}
	return "", false
}

// SetSubscribe will overwrite whatever value is currently set for Subscribe.
// Usage:
// a.SetSubscribe("")
func (a *MailingList) SetSubscribe(value string) {
	copy := value
	a.Subscribe = &copy

}

// GetUnsubscribe Gets the value of Unsubscribe and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetUnsubscribe(); ok {
//        fmt.Println(value)
//    }
func (a *MailingList) GetUnsubscribe() (returnValue string, exists bool) {
	if a.Unsubscribe != nil {
		return *a.Unsubscribe, true
	}
	return "", false
}

// SetUnsubscribe will overwrite whatever value is currently set for Unsubscribe.
// Usage:
// a.SetUnsubscribe("")
func (a *MailingList) SetUnsubscribe(value string) {
	copy := value
	a.Unsubscribe = &copy

}

// GetPost Gets the value of Post and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetPost(); ok {
//        fmt.Println(value)
//    }
func (a *MailingList) GetPost() (returnValue string, exists bool) {
	if a.Post != nil {
		return *a.Post, true
	}
	return "", false
}

// SetPost will overwrite whatever value is currently set for Post.
// Usage:
// a.SetPost("")
func (a *MailingList) SetPost(value string) {
	copy := value
	a.Post = &copy

}

// GetArchive Gets the value of Archive and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetArchive(); ok {
//        fmt.Println(value)
//    }
func (a *MailingList) GetArchive() (returnValue string, exists bool) {
	if a.Archive != nil {
		return *a.Archive, true
	}
	return "", false
}

// SetArchive will overwrite whatever value is currently set for Archive.
// Usage:
// a.SetArchive("")
func (a *MailingList) SetArchive(value string) {
	copy := value
	a.Archive = &copy

}

// GetOtherArchives Gets the value of OtherArchives and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetOtherArchives(); ok {
//        fmt.Println(value)
//    }
func (a *MailingList) GetOtherArchives() (returnValue SequenceOtherArchive, exists bool) {
	if a.OtherArchives != nil {
		return *a.OtherArchives, true
	}
	return SequenceOtherArchive{}, false
}

// SetOtherArchives will overwrite whatever value is currently set for OtherArchives.
// Usage:
// a.SetOtherArchives(SequenceOtherArchive{})
func (a *MailingList) SetOtherArchives(value SequenceOtherArchive) {
	copy := value
	a.OtherArchives = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *MailingList) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *MailingList) SetComment(value string) {
	a.Comment = value

}

// Contributor Description of a person who has contributed to the project, but who does not have
//        commit privileges. Usually, these contributions come in the form of patches submitted.
type Contributor struct {

	/* Name The full name of the contributor.*/
	Name *string `xml:"name,omitempty"`

	/* Email The email address of the contributor.*/
	Email *string `xml:"email,omitempty"`

	/* Url The URL for the homepage of the contributor.*/
	URL *string `xml:"url,omitempty"`

	/* Organization The organization to which the contributor belongs.*/
	Organization *string `xml:"organization,omitempty"`

	/* OrganizationUrl The URL of the organization.*/
	OrganizationURL *string `xml:"organizationUrl,omitempty"`

	/* Roles The roles the contributor plays in the project. Each role is described by a
	   <code>role</code> element, the body of which is a role name. This can also be used to
	   describe the contribution.*/
	Roles *SequenceRole `xml:"roles,omitempty"`

	/* Timezone The timezone the contributor is in. Typically, this is a number in the range
	   <a href="http://en.wikipedia.org/wiki/UTC%E2%88%9212:00">-12</a> to <a href="http://en.wikipedia.org/wiki/UTC%2B14:00">+14</a>
	   or a valid time zone id like "America/Montreal" (UTC-05:00) or "Europe/Paris" (UTC+01:00).*/
	Timezone *string `xml:"timezone,omitempty"`

	/* Properties Properties about the contributor, such as an instant messenger handle.*/
	Properties *XMLProperties `xml:"properties,omitempty"`

	Comment string `xml:",comment"`
}

// GetName Gets the value of Name and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetName(); ok {
//        fmt.Println(value)
//    }
func (a *Contributor) GetName() (returnValue string, exists bool) {
	if a.Name != nil {
		return *a.Name, true
	}
	return "", false
}

// SetName will overwrite whatever value is currently set for Name.
// Usage:
// a.SetName("")
func (a *Contributor) SetName(value string) {
	copy := value
	a.Name = &copy

}

// GetEmail Gets the value of Email and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetEmail(); ok {
//        fmt.Println(value)
//    }
func (a *Contributor) GetEmail() (returnValue string, exists bool) {
	if a.Email != nil {
		return *a.Email, true
	}
	return "", false
}

// SetEmail will overwrite whatever value is currently set for Email.
// Usage:
// a.SetEmail("")
func (a *Contributor) SetEmail(value string) {
	copy := value
	a.Email = &copy

}

// GetURL Gets the value of URL and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetURL(); ok {
//        fmt.Println(value)
//    }
func (a *Contributor) GetURL() (returnValue string, exists bool) {
	if a.URL != nil {
		return *a.URL, true
	}
	return "", false
}

// SetURL will overwrite whatever value is currently set for URL.
// Usage:
// a.SetURL("")
func (a *Contributor) SetURL(value string) {
	copy := value
	a.URL = &copy

}

// GetOrganization Gets the value of Organization and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetOrganization(); ok {
//        fmt.Println(value)
//    }
func (a *Contributor) GetOrganization() (returnValue string, exists bool) {
	if a.Organization != nil {
		return *a.Organization, true
	}
	return "", false
}

// SetOrganization will overwrite whatever value is currently set for Organization.
// Usage:
// a.SetOrganization("")
func (a *Contributor) SetOrganization(value string) {
	copy := value
	a.Organization = &copy

}

// GetOrganizationURL Gets the value of OrganizationURL and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetOrganizationURL(); ok {
//        fmt.Println(value)
//    }
func (a *Contributor) GetOrganizationURL() (returnValue string, exists bool) {
	if a.OrganizationURL != nil {
		return *a.OrganizationURL, true
	}
	return "", false
}

// SetOrganizationURL will overwrite whatever value is currently set for OrganizationURL.
// Usage:
// a.SetOrganizationURL("")
func (a *Contributor) SetOrganizationURL(value string) {
	copy := value
	a.OrganizationURL = &copy

}

// GetRoles Gets the value of Roles and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetRoles(); ok {
//        fmt.Println(value)
//    }
func (a *Contributor) GetRoles() (returnValue SequenceRole, exists bool) {
	if a.Roles != nil {
		return *a.Roles, true
	}
	return SequenceRole{}, false
}

// SetRoles will overwrite whatever value is currently set for Roles.
// Usage:
// a.SetRoles(SequenceRole{})
func (a *Contributor) SetRoles(value SequenceRole) {
	copy := value
	a.Roles = &copy

}

// GetTimezone Gets the value of Timezone and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetTimezone(); ok {
//        fmt.Println(value)
//    }
func (a *Contributor) GetTimezone() (returnValue string, exists bool) {
	if a.Timezone != nil {
		return *a.Timezone, true
	}
	return "", false
}

// SetTimezone will overwrite whatever value is currently set for Timezone.
// Usage:
// a.SetTimezone("")
func (a *Contributor) SetTimezone(value string) {
	copy := value
	a.Timezone = &copy

}

// GetProperties Gets the value of Properties and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetProperties(); ok {
//        fmt.Println(value)
//    }
func (a *Contributor) GetProperties() (returnValue XMLProperties, exists bool) {
	if a.Properties != nil {
		return *a.Properties, true
	}
	return XMLProperties{}, false
}

// SetProperties will overwrite whatever value is currently set for Properties.
// Usage:
// a.SetProperties(XMLProperties{})
func (a *Contributor) SetProperties(value XMLProperties) {
	copy := value
	a.Properties = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *Contributor) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *Contributor) SetComment(value string) {
	a.Comment = value

}

// Organization Specifies the organization that produces this project.
type Organization struct {

	/* Name The full name of the organization.*/
	Name *string `xml:"name,omitempty"`

	/* Url The URL to the organization's home page.*/
	URL *string `xml:"url,omitempty"`

	Comment string `xml:",comment"`
}

// GetName Gets the value of Name and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetName(); ok {
//        fmt.Println(value)
//    }
func (a *Organization) GetName() (returnValue string, exists bool) {
	if a.Name != nil {
		return *a.Name, true
	}
	return "", false
}

// SetName will overwrite whatever value is currently set for Name.
// Usage:
// a.SetName("")
func (a *Organization) SetName(value string) {
	copy := value
	a.Name = &copy

}

// GetURL Gets the value of URL and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetURL(); ok {
//        fmt.Println(value)
//    }
func (a *Organization) GetURL() (returnValue string, exists bool) {
	if a.URL != nil {
		return *a.URL, true
	}
	return "", false
}

// SetURL will overwrite whatever value is currently set for URL.
// Usage:
// a.SetURL("")
func (a *Organization) SetURL(value string) {
	copy := value
	a.URL = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *Organization) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *Organization) SetComment(value string) {
	a.Comment = value

}

// DistributionManagement This elements describes all that pertains to distribution for a project. It is
//        primarily used for deployment of artifacts and the site produced by the build.
type DistributionManagement struct {

	/* Repository Information needed to deploy the artifacts generated by the project to a
	   remote repository.*/
	Repository *DeploymentRepository `xml:"repository,omitempty"`

	/* SnapshotRepository Where to deploy snapshots of artifacts to. If not given, it defaults to the
	   <code>repository</code> element.*/
	SnapshotRepository *DeploymentRepository `xml:"snapshotRepository,omitempty"`

	/* Site Information needed for deploying the web site of the project.*/
	Site *Site `xml:"site,omitempty"`

	/* DownloadUrl The URL of the project's download page. If not given users will be
	   referred to the homepage given by <code>url</code>.
	   This is given to assist in locating artifacts that are not in the repository due to
	   licensing restrictions.*/
	DownloadURL *string `xml:"downloadUrl,omitempty"`

	/* Relocation Relocation information of the artifact if it has been moved to a new group ID
	   and/or artifact ID.*/
	Relocation *Relocation `xml:"relocation,omitempty"`

	/* Status Gives the status of this artifact in the remote repository.
	   This must not be set in your local project, as it is updated by
	   tools placing it in the reposiory. Valid values are: <code>none</code> (default),
	   <code>converted</code> (repository manager converted this from an Maven 1 POM),
	   <code>partner</code>
	   (directly synced from a partner Maven 2 repository), <code>deployed</code> (was deployed from a Maven 2
	   instance), <code>verified</code> (has been hand verified as correct and final).*/
	Status *string `xml:"status,omitempty"`

	Comment string `xml:",comment"`
}

// GetRepository Gets the value of Repository and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetRepository(); ok {
//        fmt.Println(value)
//    }
func (a *DistributionManagement) GetRepository() (returnValue DeploymentRepository, exists bool) {
	if a.Repository != nil {
		return *a.Repository, true
	}
	return DeploymentRepository{}, false
}

// SetRepository will overwrite whatever value is currently set for Repository.
// Usage:
// a.SetRepository(DeploymentRepository{})
func (a *DistributionManagement) SetRepository(value DeploymentRepository) {
	copy := value
	a.Repository = &copy

}

// GetSnapshotRepository Gets the value of SnapshotRepository and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetSnapshotRepository(); ok {
//        fmt.Println(value)
//    }
func (a *DistributionManagement) GetSnapshotRepository() (returnValue DeploymentRepository, exists bool) {
	if a.SnapshotRepository != nil {
		return *a.SnapshotRepository, true
	}
	return DeploymentRepository{}, false
}

// SetSnapshotRepository will overwrite whatever value is currently set for SnapshotRepository.
// Usage:
// a.SetSnapshotRepository(DeploymentRepository{})
func (a *DistributionManagement) SetSnapshotRepository(value DeploymentRepository) {
	copy := value
	a.SnapshotRepository = &copy

}

// GetSite Gets the value of Site and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetSite(); ok {
//        fmt.Println(value)
//    }
func (a *DistributionManagement) GetSite() (returnValue Site, exists bool) {
	if a.Site != nil {
		return *a.Site, true
	}
	return Site{}, false
}

// SetSite will overwrite whatever value is currently set for Site.
// Usage:
// a.SetSite(Site{})
func (a *DistributionManagement) SetSite(value Site) {
	copy := value
	a.Site = &copy

}

// GetDownloadURL Gets the value of DownloadURL and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetDownloadURL(); ok {
//        fmt.Println(value)
//    }
func (a *DistributionManagement) GetDownloadURL() (returnValue string, exists bool) {
	if a.DownloadURL != nil {
		return *a.DownloadURL, true
	}
	return "", false
}

// SetDownloadURL will overwrite whatever value is currently set for DownloadURL.
// Usage:
// a.SetDownloadURL("")
func (a *DistributionManagement) SetDownloadURL(value string) {
	copy := value
	a.DownloadURL = &copy

}

// GetRelocation Gets the value of Relocation and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetRelocation(); ok {
//        fmt.Println(value)
//    }
func (a *DistributionManagement) GetRelocation() (returnValue Relocation, exists bool) {
	if a.Relocation != nil {
		return *a.Relocation, true
	}
	return Relocation{}, false
}

// SetRelocation will overwrite whatever value is currently set for Relocation.
// Usage:
// a.SetRelocation(Relocation{})
func (a *DistributionManagement) SetRelocation(value Relocation) {
	copy := value
	a.Relocation = &copy

}

// GetStatus Gets the value of Status and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetStatus(); ok {
//        fmt.Println(value)
//    }
func (a *DistributionManagement) GetStatus() (returnValue string, exists bool) {
	if a.Status != nil {
		return *a.Status, true
	}
	return "", false
}

// SetStatus will overwrite whatever value is currently set for Status.
// Usage:
// a.SetStatus("")
func (a *DistributionManagement) SetStatus(value string) {
	copy := value
	a.Status = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *DistributionManagement) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *DistributionManagement) SetComment(value string) {
	a.Comment = value

}

// DeploymentRepository Repository contains the information needed for deploying to the remote
//        repository.
type DeploymentRepository struct {

	/* UniqueVersion Whether to assign snapshots a unique version comprised of the timestamp and
	   build number, or to use the same version each time*/
	UniqueVersion *bool `xml:"uniqueVersion,omitempty"`

	/* Releases How to handle downloading of releases from this repository.*/
	Releases *RepositoryPolicy `xml:"releases,omitempty"`

	/* Snapshots How to handle downloading of snapshots from this repository.*/
	Snapshots *RepositoryPolicy `xml:"snapshots,omitempty"`

	/* Id A unique identifier for a repository. This is used to match the repository
	   to configuration in the <code>settings.xml</code> file, for example. Furthermore, the identifier is
	   used during POM inheritance and profile injection to detect repositories that should be merged.*/
	ID *string `xml:"id,omitempty"`

	/* Name Human readable name of the repository.*/
	Name *string `xml:"name,omitempty"`

	/* Url The url of the repository, in the form <code>protocol://hostname/path</code>.*/
	URL *string `xml:"url,omitempty"`

	/* Layout The type of layout this repository uses for locating and storing artifacts -
	   can be <code>legacy</code> or <code>default</code>.*/
	Layout *string `xml:"layout,omitempty"`

	Comment string `xml:",comment"`
}

// GetUniqueVersion Gets the value of UniqueVersion and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetUniqueVersion(); ok {
//        fmt.Println(value)
//    }
func (a *DeploymentRepository) GetUniqueVersion() (returnValue bool, exists bool) {
	if a.UniqueVersion != nil {
		return *a.UniqueVersion, true
	}
	return false, false
}

// SetUniqueVersion will overwrite whatever value is currently set for UniqueVersion.
// Usage:
// a.SetUniqueVersion(false)
func (a *DeploymentRepository) SetUniqueVersion(value bool) {
	copy := value
	a.UniqueVersion = &copy

}

// GetReleases Gets the value of Releases and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetReleases(); ok {
//        fmt.Println(value)
//    }
func (a *DeploymentRepository) GetReleases() (returnValue RepositoryPolicy, exists bool) {
	if a.Releases != nil {
		return *a.Releases, true
	}
	return RepositoryPolicy{}, false
}

// SetReleases will overwrite whatever value is currently set for Releases.
// Usage:
// a.SetReleases(RepositoryPolicy{})
func (a *DeploymentRepository) SetReleases(value RepositoryPolicy) {
	copy := value
	a.Releases = &copy

}

// GetSnapshots Gets the value of Snapshots and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetSnapshots(); ok {
//        fmt.Println(value)
//    }
func (a *DeploymentRepository) GetSnapshots() (returnValue RepositoryPolicy, exists bool) {
	if a.Snapshots != nil {
		return *a.Snapshots, true
	}
	return RepositoryPolicy{}, false
}

// SetSnapshots will overwrite whatever value is currently set for Snapshots.
// Usage:
// a.SetSnapshots(RepositoryPolicy{})
func (a *DeploymentRepository) SetSnapshots(value RepositoryPolicy) {
	copy := value
	a.Snapshots = &copy

}

// GetID Gets the value of ID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetID(); ok {
//        fmt.Println(value)
//    }
func (a *DeploymentRepository) GetID() (returnValue string, exists bool) {
	if a.ID != nil {
		return *a.ID, true
	}
	return "", false
}

// SetID will overwrite whatever value is currently set for ID.
// Usage:
// a.SetID("")
func (a *DeploymentRepository) SetID(value string) {
	copy := value
	a.ID = &copy

}

// GetName Gets the value of Name and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetName(); ok {
//        fmt.Println(value)
//    }
func (a *DeploymentRepository) GetName() (returnValue string, exists bool) {
	if a.Name != nil {
		return *a.Name, true
	}
	return "", false
}

// SetName will overwrite whatever value is currently set for Name.
// Usage:
// a.SetName("")
func (a *DeploymentRepository) SetName(value string) {
	copy := value
	a.Name = &copy

}

// GetURL Gets the value of URL and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetURL(); ok {
//        fmt.Println(value)
//    }
func (a *DeploymentRepository) GetURL() (returnValue string, exists bool) {
	if a.URL != nil {
		return *a.URL, true
	}
	return "", false
}

// SetURL will overwrite whatever value is currently set for URL.
// Usage:
// a.SetURL("")
func (a *DeploymentRepository) SetURL(value string) {
	copy := value
	a.URL = &copy

}

// GetLayout Gets the value of Layout and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetLayout(); ok {
//        fmt.Println(value)
//    }
func (a *DeploymentRepository) GetLayout() (returnValue string, exists bool) {
	if a.Layout != nil {
		return *a.Layout, true
	}
	return "", false
}

// SetLayout will overwrite whatever value is currently set for Layout.
// Usage:
// a.SetLayout("")
func (a *DeploymentRepository) SetLayout(value string) {
	copy := value
	a.Layout = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *DeploymentRepository) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *DeploymentRepository) SetComment(value string) {
	a.Comment = value

}

// RepositoryPolicy Download policy.
type RepositoryPolicy struct {

	/* Enabled Whether to use this repository for downloading this type of artifact. Note: While the type
	   of this field is <code>String</code> for technical reasons, the semantic type is actually
	   <code>Boolean</code>. Default value is <code>true</code>.*/
	Enabled *string `xml:"enabled,omitempty"`

	/* UpdatePolicy The frequency for downloading updates - can be
	   <code>always,</code>
	   <code>daily</code>
	   (default),
	   <code>interval:XXX</code>
	   (in minutes) or
	   <code>never</code>
	   (only if it doesn't exist locally).*/
	UpdatePolicy *string `xml:"updatePolicy,omitempty"`

	/* ChecksumPolicy What to do when verification of an artifact checksum fails. Valid values are
	   <code>ignore</code>
	   ,
	   <code>fail</code>
	   or
	   <code>warn</code>
	   (the default).*/
	ChecksumPolicy *string `xml:"checksumPolicy,omitempty"`

	Comment string `xml:",comment"`
}

// GetEnabled Gets the value of Enabled and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetEnabled(); ok {
//        fmt.Println(value)
//    }
func (a *RepositoryPolicy) GetEnabled() (returnValue string, exists bool) {
	if a.Enabled != nil {
		return *a.Enabled, true
	}
	return "", false
}

// SetEnabled will overwrite whatever value is currently set for Enabled.
// Usage:
// a.SetEnabled("")
func (a *RepositoryPolicy) SetEnabled(value string) {
	copy := value
	a.Enabled = &copy

}

// GetUpdatePolicy Gets the value of UpdatePolicy and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetUpdatePolicy(); ok {
//        fmt.Println(value)
//    }
func (a *RepositoryPolicy) GetUpdatePolicy() (returnValue string, exists bool) {
	if a.UpdatePolicy != nil {
		return *a.UpdatePolicy, true
	}
	return "", false
}

// SetUpdatePolicy will overwrite whatever value is currently set for UpdatePolicy.
// Usage:
// a.SetUpdatePolicy("")
func (a *RepositoryPolicy) SetUpdatePolicy(value string) {
	copy := value
	a.UpdatePolicy = &copy

}

// GetChecksumPolicy Gets the value of ChecksumPolicy and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetChecksumPolicy(); ok {
//        fmt.Println(value)
//    }
func (a *RepositoryPolicy) GetChecksumPolicy() (returnValue string, exists bool) {
	if a.ChecksumPolicy != nil {
		return *a.ChecksumPolicy, true
	}
	return "", false
}

// SetChecksumPolicy will overwrite whatever value is currently set for ChecksumPolicy.
// Usage:
// a.SetChecksumPolicy("")
func (a *RepositoryPolicy) SetChecksumPolicy(value string) {
	copy := value
	a.ChecksumPolicy = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *RepositoryPolicy) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *RepositoryPolicy) SetComment(value string) {
	a.Comment = value

}

// Relocation Describes where an artifact has moved to. If any of the values are omitted, it is
//        assumed to be the same as it was before.
type Relocation struct {

	/* GroupId The group ID the artifact has moved to.*/
	GroupID *string `xml:"groupId,omitempty"`

	/* ArtifactId The new artifact ID of the artifact.*/
	ArtifactID *string `xml:"artifactId,omitempty"`

	/* Version The new version of the artifact.*/
	Version *string `xml:"version,omitempty"`

	/* Message An additional message to show the user about the move, such as the reason.*/
	Message *string `xml:"message,omitempty"`

	Comment string `xml:",comment"`
}

// GetGroupID Gets the value of GroupID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetGroupID(); ok {
//        fmt.Println(value)
//    }
func (a *Relocation) GetGroupID() (returnValue string, exists bool) {
	if a.GroupID != nil {
		return *a.GroupID, true
	}
	return "", false
}

// SetGroupID will overwrite whatever value is currently set for GroupID.
// Usage:
// a.SetGroupID("")
func (a *Relocation) SetGroupID(value string) {
	copy := value
	a.GroupID = &copy

}

// GetArtifactID Gets the value of ArtifactID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetArtifactID(); ok {
//        fmt.Println(value)
//    }
func (a *Relocation) GetArtifactID() (returnValue string, exists bool) {
	if a.ArtifactID != nil {
		return *a.ArtifactID, true
	}
	return "", false
}

// SetArtifactID will overwrite whatever value is currently set for ArtifactID.
// Usage:
// a.SetArtifactID("")
func (a *Relocation) SetArtifactID(value string) {
	copy := value
	a.ArtifactID = &copy

}

// GetVersion Gets the value of Version and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetVersion(); ok {
//        fmt.Println(value)
//    }
func (a *Relocation) GetVersion() (returnValue string, exists bool) {
	if a.Version != nil {
		return *a.Version, true
	}
	return "", false
}

// SetVersion will overwrite whatever value is currently set for Version.
// Usage:
// a.SetVersion("")
func (a *Relocation) SetVersion(value string) {
	copy := value
	a.Version = &copy

}

// GetMessage Gets the value of Message and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetMessage(); ok {
//        fmt.Println(value)
//    }
func (a *Relocation) GetMessage() (returnValue string, exists bool) {
	if a.Message != nil {
		return *a.Message, true
	}
	return "", false
}

// SetMessage will overwrite whatever value is currently set for Message.
// Usage:
// a.SetMessage("")
func (a *Relocation) SetMessage(value string) {
	copy := value
	a.Message = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *Relocation) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *Relocation) SetComment(value string) {
	a.Comment = value

}

// Site Contains the information needed for deploying websites.
type Site struct {

	/* Id A unique identifier for a deployment location. This is used to match the
	   site to configuration in the <code>settings.xml</code> file, for example.*/
	ID *string `xml:"id,omitempty"`

	/* Name Human readable name of the deployment location.*/
	Name *string `xml:"name,omitempty"`

	/* Url The url of the location where website is deployed, in the form <code>protocol://hostname/path</code>.
	   <br><b>Default value is</b>: parent value [+ path adjustment] + (artifactId or project.directory property), or just parent value if
	   site's <code>child.site.url.inherit.append.path="false"</code>*/
	URL *string `xml:"url,omitempty"`

	Comment string `xml:",comment"`
}

// GetID Gets the value of ID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetID(); ok {
//        fmt.Println(value)
//    }
func (a *Site) GetID() (returnValue string, exists bool) {
	if a.ID != nil {
		return *a.ID, true
	}
	return "", false
}

// SetID will overwrite whatever value is currently set for ID.
// Usage:
// a.SetID("")
func (a *Site) SetID(value string) {
	copy := value
	a.ID = &copy

}

// GetName Gets the value of Name and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetName(); ok {
//        fmt.Println(value)
//    }
func (a *Site) GetName() (returnValue string, exists bool) {
	if a.Name != nil {
		return *a.Name, true
	}
	return "", false
}

// SetName will overwrite whatever value is currently set for Name.
// Usage:
// a.SetName("")
func (a *Site) SetName(value string) {
	copy := value
	a.Name = &copy

}

// GetURL Gets the value of URL and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetURL(); ok {
//        fmt.Println(value)
//    }
func (a *Site) GetURL() (returnValue string, exists bool) {
	if a.URL != nil {
		return *a.URL, true
	}
	return "", false
}

// SetURL will overwrite whatever value is currently set for URL.
// Usage:
// a.SetURL("")
func (a *Site) SetURL(value string) {
	copy := value
	a.URL = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *Site) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *Site) SetComment(value string) {
	a.Comment = value

}

// SequencePlugin contains the subelements for iterables in XML
type SequencePlugin struct {
	Comment string `xml:",comment"`

	Plugin []*ReportPlugin `xml:"plugin,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequencePlugin) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequencePlugin) SetComment(value string) {
	a.Comment = value

}

// GetPlugin Gets the value of Plugin and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetPlugin(); ok {
//        fmt.Println(value)
//    }
func (a *SequencePlugin) GetPlugin() (returnValue []*ReportPlugin) {
	if a.Plugin != nil {
		return a.Plugin
	}
	return []*ReportPlugin{}
}

// SetPlugin will overwrite whatever value is currently set for Plugin.
// Usage:
// a.SetPlugin(ReportPlugin{})
func (a *SequencePlugin) SetPlugin(value []*ReportPlugin) {
	a.Plugin = value

}

// UpdatePlugin will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := ReportPlugin{ }
// a.UpdatePlugin(value, 2)
func (a *SequencePlugin) UpdatePlugin(value *ReportPlugin, index int) {
	current := a.GetPlugin()
	if len(current) > index {
		a.Plugin[index] = value
	}
	a.Plugin = append(current, value)
}

// AddPlugin adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := ReportPlugin{ }
// a.AddPlugin(value)
func (a *SequencePlugin) AddPlugin(value *ReportPlugin) {
	a.Plugin = append(a.Plugin, value)
}

// Reporting Section for management of reports and their configuration.
type Reporting struct {

	/* ExcludeDefaults If true, then the default reports are not included in the site generation.
	   This includes the reports in the "Project Info" menu. Note: While the type
	   of this field is <code>String</code> for technical reasons, the semantic type is actually
	   <code>Boolean</code>. Default value is <code>false</code>.*/
	ExcludeDefaults *string `xml:"excludeDefaults,omitempty"`

	/* OutputDirectory Where to store all of the generated reports. The default is
	   <code>${project.build.directory}/site</code>.*/
	OutputDirectory *string `xml:"outputDirectory,omitempty"`

	/* Plugins The reporting plugins to use and their configuration.*/
	Plugins *SequencePlugin `xml:"plugins,omitempty"`

	Comment string `xml:",comment"`
}

// GetExcludeDefaults Gets the value of ExcludeDefaults and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetExcludeDefaults(); ok {
//        fmt.Println(value)
//    }
func (a *Reporting) GetExcludeDefaults() (returnValue string, exists bool) {
	if a.ExcludeDefaults != nil {
		return *a.ExcludeDefaults, true
	}
	return "", false
}

// SetExcludeDefaults will overwrite whatever value is currently set for ExcludeDefaults.
// Usage:
// a.SetExcludeDefaults("")
func (a *Reporting) SetExcludeDefaults(value string) {
	copy := value
	a.ExcludeDefaults = &copy

}

// GetOutputDirectory Gets the value of OutputDirectory and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetOutputDirectory(); ok {
//        fmt.Println(value)
//    }
func (a *Reporting) GetOutputDirectory() (returnValue string, exists bool) {
	if a.OutputDirectory != nil {
		return *a.OutputDirectory, true
	}
	return "", false
}

// SetOutputDirectory will overwrite whatever value is currently set for OutputDirectory.
// Usage:
// a.SetOutputDirectory("")
func (a *Reporting) SetOutputDirectory(value string) {
	copy := value
	a.OutputDirectory = &copy

}

// GetPlugins Gets the value of Plugins and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetPlugins(); ok {
//        fmt.Println(value)
//    }
func (a *Reporting) GetPlugins() (returnValue SequencePlugin, exists bool) {
	if a.Plugins != nil {
		return *a.Plugins, true
	}
	return SequencePlugin{}, false
}

// SetPlugins will overwrite whatever value is currently set for Plugins.
// Usage:
// a.SetPlugins(SequencePlugin{})
func (a *Reporting) SetPlugins(value SequencePlugin) {
	copy := value
	a.Plugins = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *Reporting) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *Reporting) SetComment(value string) {
	a.Comment = value

}

// SequenceReportSet contains the subelements for iterables in XML
type SequenceReportSet struct {
	Comment string `xml:",comment"`

	ReportSet []*ReportSet `xml:"reportSet,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceReportSet) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequenceReportSet) SetComment(value string) {
	a.Comment = value

}

// GetReportSet Gets the value of ReportSet and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetReportSet(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceReportSet) GetReportSet() (returnValue []*ReportSet) {
	if a.ReportSet != nil {
		return a.ReportSet
	}
	return []*ReportSet{}
}

// SetReportSet will overwrite whatever value is currently set for ReportSet.
// Usage:
// a.SetReportSet(ReportSet{})
func (a *SequenceReportSet) SetReportSet(value []*ReportSet) {
	a.ReportSet = value

}

// UpdateReportSet will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := ReportSet{ }
// a.UpdateReportSet(value, 2)
func (a *SequenceReportSet) UpdateReportSet(value *ReportSet, index int) {
	current := a.GetReportSet()
	if len(current) > index {
		a.ReportSet[index] = value
	}
	a.ReportSet = append(current, value)
}

// AddReportSet adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := ReportSet{ }
// a.AddReportSet(value)
func (a *SequenceReportSet) AddReportSet(value *ReportSet) {
	a.ReportSet = append(a.ReportSet, value)
}

// ReportPlugin The <code>&lt;plugin&gt;</code> element contains informations required for a report plugin.
type ReportPlugin struct {

	/* GroupId The group ID of the reporting plugin in the repository.*/
	GroupID *string `xml:"groupId,omitempty"`

	/* ArtifactId The artifact ID of the reporting plugin in the repository.*/
	ArtifactID *string `xml:"artifactId,omitempty"`

	/* Version The version of the reporting plugin to be used.*/
	Version *string `xml:"version,omitempty"`

	/* ReportSets Multiple specifications of a set of reports, each having (possibly) different
	   configuration. This is the reporting parallel to an <code>execution</code> in the build.*/
	ReportSets *SequenceReportSet `xml:"reportSets,omitempty"`

	/* Inherited Whether any configuration should be propagated to child POMs. Note: While the type
	   of this field is <code>String</code> for technical reasons, the semantic type is actually
	   <code>Boolean</code>. Default value is <code>true</code>.*/
	Inherited *string `xml:"inherited,omitempty"`

	/* Configuration <p>The configuration as DOM object.</p>
	   <p>By default, every element content is trimmed, but starting with Maven 3.1.0, you can add
	   <code>xml:space="preserve"</code> to elements you want to preserve whitespace.</p>
	   <p>You can control how child POMs inherit configuration from parent POMs by adding <code>combine.children</code>
	   or <code>combine.self</code> attributes to the children of the configuration element:</p>
	   <ul>
	   <li><code>combine.children</code>: available values are <code>merge</code> (default) and <code>append</code>,</li>
	   <li><code>combine.self</code>: available values are <code>merge</code> (default) and <code>override</code>.</li>
	   </ul>
	   <p>See <a href="https://maven.apache.org/pom.html#Plugins">POM Reference documentation</a> and
	   <a href="https://codehaus-plexus.github.io/plexus-utils/apidocs/org/codehaus/plexus/util/xml/Xpp3DomUtils.html">Xpp3DomUtils</a>
	   for more information.</p>*/
	Configuration *XMLInner `xml:"configuration,omitempty"`

	Comment string `xml:",comment"`
}

// GetGroupID Gets the value of GroupID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetGroupID(); ok {
//        fmt.Println(value)
//    }
func (a *ReportPlugin) GetGroupID() (returnValue string, exists bool) {
	if a.GroupID != nil {
		return *a.GroupID, true
	}
	return "", false
}

// SetGroupID will overwrite whatever value is currently set for GroupID.
// Usage:
// a.SetGroupID("")
func (a *ReportPlugin) SetGroupID(value string) {
	copy := value
	a.GroupID = &copy

}

// GetArtifactID Gets the value of ArtifactID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetArtifactID(); ok {
//        fmt.Println(value)
//    }
func (a *ReportPlugin) GetArtifactID() (returnValue string, exists bool) {
	if a.ArtifactID != nil {
		return *a.ArtifactID, true
	}
	return "", false
}

// SetArtifactID will overwrite whatever value is currently set for ArtifactID.
// Usage:
// a.SetArtifactID("")
func (a *ReportPlugin) SetArtifactID(value string) {
	copy := value
	a.ArtifactID = &copy

}

// GetVersion Gets the value of Version and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetVersion(); ok {
//        fmt.Println(value)
//    }
func (a *ReportPlugin) GetVersion() (returnValue string, exists bool) {
	if a.Version != nil {
		return *a.Version, true
	}
	return "", false
}

// SetVersion will overwrite whatever value is currently set for Version.
// Usage:
// a.SetVersion("")
func (a *ReportPlugin) SetVersion(value string) {
	copy := value
	a.Version = &copy

}

// GetReportSets Gets the value of ReportSets and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetReportSets(); ok {
//        fmt.Println(value)
//    }
func (a *ReportPlugin) GetReportSets() (returnValue SequenceReportSet, exists bool) {
	if a.ReportSets != nil {
		return *a.ReportSets, true
	}
	return SequenceReportSet{}, false
}

// SetReportSets will overwrite whatever value is currently set for ReportSets.
// Usage:
// a.SetReportSets(SequenceReportSet{})
func (a *ReportPlugin) SetReportSets(value SequenceReportSet) {
	copy := value
	a.ReportSets = &copy

}

// GetInherited Gets the value of Inherited and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetInherited(); ok {
//        fmt.Println(value)
//    }
func (a *ReportPlugin) GetInherited() (returnValue string, exists bool) {
	if a.Inherited != nil {
		return *a.Inherited, true
	}
	return "", false
}

// SetInherited will overwrite whatever value is currently set for Inherited.
// Usage:
// a.SetInherited("")
func (a *ReportPlugin) SetInherited(value string) {
	copy := value
	a.Inherited = &copy

}

// GetConfiguration Gets the value of Configuration and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetConfiguration(); ok {
//        fmt.Println(value)
//    }
func (a *ReportPlugin) GetConfiguration() (returnValue XMLInner, exists bool) {
	if a.Configuration != nil {
		return *a.Configuration, true
	}
	return XMLInner{}, false
}

// SetConfiguration will overwrite whatever value is currently set for Configuration.
// Usage:
// a.SetConfiguration(XMLInner{})
func (a *ReportPlugin) SetConfiguration(value XMLInner) {
	copy := value
	a.Configuration = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *ReportPlugin) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *ReportPlugin) SetComment(value string) {
	a.Comment = value

}

// SequenceReport contains the subelements for iterables in XML
type SequenceReport struct {
	Comment string `xml:",comment"`

	Report []*string `xml:"report,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceReport) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequenceReport) SetComment(value string) {
	a.Comment = value

}

// GetReport Gets the value of Report and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetReport(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceReport) GetReport() (returnValue []*string) {
	if a.Report != nil {
		return a.Report
	}
	return []*string{}
}

// SetReport will overwrite whatever value is currently set for Report.
// Usage:
// a.SetReport(string{})
func (a *SequenceReport) SetReport(value []*string) {
	a.Report = value

}

// UpdateReport will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := string{ }
// a.UpdateReport(value, 2)
func (a *SequenceReport) UpdateReport(value *string, index int) {
	current := a.GetReport()
	if len(current) > index {
		a.Report[index] = value
	}
	a.Report = append(current, value)
}

// AddReport adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := string{ }
// a.AddReport(value)
func (a *SequenceReport) AddReport(value *string) {
	a.Report = append(a.Report, value)
}

// ReportSet Represents a set of reports and configuration to be used to generate them.
type ReportSet struct {

	/* Id The unique id for this report set, to be used during POM inheritance and profile injection
	   for merging of report sets.*/
	ID *string `xml:"id,omitempty"`

	/* Reports The list of reports from this plugin which should be generated from this set.*/
	Reports *SequenceReport `xml:"reports,omitempty"`

	/* Inherited Whether any configuration should be propagated to child POMs. Note: While the type
	   of this field is <code>String</code> for technical reasons, the semantic type is actually
	   <code>Boolean</code>. Default value is <code>true</code>.*/
	Inherited *string `xml:"inherited,omitempty"`

	/* Configuration <p>The configuration as DOM object.</p>
	   <p>By default, every element content is trimmed, but starting with Maven 3.1.0, you can add
	   <code>xml:space="preserve"</code> to elements you want to preserve whitespace.</p>
	   <p>You can control how child POMs inherit configuration from parent POMs by adding <code>combine.children</code>
	   or <code>combine.self</code> attributes to the children of the configuration element:</p>
	   <ul>
	   <li><code>combine.children</code>: available values are <code>merge</code> (default) and <code>append</code>,</li>
	   <li><code>combine.self</code>: available values are <code>merge</code> (default) and <code>override</code>.</li>
	   </ul>
	   <p>See <a href="https://maven.apache.org/pom.html#Plugins">POM Reference documentation</a> and
	   <a href="https://codehaus-plexus.github.io/plexus-utils/apidocs/org/codehaus/plexus/util/xml/Xpp3DomUtils.html">Xpp3DomUtils</a>
	   for more information.</p>*/
	Configuration *XMLInner `xml:"configuration,omitempty"`

	Comment string `xml:",comment"`
}

// GetID Gets the value of ID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetID(); ok {
//        fmt.Println(value)
//    }
func (a *ReportSet) GetID() (returnValue string, exists bool) {
	if a.ID != nil {
		return *a.ID, true
	}
	return "", false
}

// SetID will overwrite whatever value is currently set for ID.
// Usage:
// a.SetID("")
func (a *ReportSet) SetID(value string) {
	copy := value
	a.ID = &copy

}

// GetReports Gets the value of Reports and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetReports(); ok {
//        fmt.Println(value)
//    }
func (a *ReportSet) GetReports() (returnValue SequenceReport, exists bool) {
	if a.Reports != nil {
		return *a.Reports, true
	}
	return SequenceReport{}, false
}

// SetReports will overwrite whatever value is currently set for Reports.
// Usage:
// a.SetReports(SequenceReport{})
func (a *ReportSet) SetReports(value SequenceReport) {
	copy := value
	a.Reports = &copy

}

// GetInherited Gets the value of Inherited and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetInherited(); ok {
//        fmt.Println(value)
//    }
func (a *ReportSet) GetInherited() (returnValue string, exists bool) {
	if a.Inherited != nil {
		return *a.Inherited, true
	}
	return "", false
}

// SetInherited will overwrite whatever value is currently set for Inherited.
// Usage:
// a.SetInherited("")
func (a *ReportSet) SetInherited(value string) {
	copy := value
	a.Inherited = &copy

}

// GetConfiguration Gets the value of Configuration and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetConfiguration(); ok {
//        fmt.Println(value)
//    }
func (a *ReportSet) GetConfiguration() (returnValue XMLInner, exists bool) {
	if a.Configuration != nil {
		return *a.Configuration, true
	}
	return XMLInner{}, false
}

// SetConfiguration will overwrite whatever value is currently set for Configuration.
// Usage:
// a.SetConfiguration(XMLInner{})
func (a *ReportSet) SetConfiguration(value XMLInner) {
	copy := value
	a.Configuration = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *ReportSet) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *ReportSet) SetComment(value string) {
	a.Comment = value

}

// Profile Modifications to the build process which is activated based on environmental
//        parameters or command line arguments.
type Profile struct {

	/* Id The identifier of this build profile. This is used for command line
	   activation, and identifies profiles to be merged.*/
	ID *string `xml:"id,omitempty"`

	/* Activation The conditional logic which will automatically trigger the inclusion of this
	   profile.*/
	Activation *Activation `xml:"activation,omitempty"`

	/* Build Information required to build the project.*/
	Build *BuildBase `xml:"build,omitempty"`

	/* Modules The modules (sometimes called subprojects) to build as a part of this
	   project. Each module listed is a relative path to the directory containing the module.
	   To be consistent with the way default urls are calculated from parent, it is recommended
	   to have module names match artifact ids.*/
	Modules *SequenceModule `xml:"modules,omitempty"`

	/* DistributionManagement Distribution information for a project that enables deployment of the site
	   and artifacts to remote web servers and repositories respectively.*/
	DistributionManagement *DistributionManagement `xml:"distributionManagement,omitempty"`

	/* Properties Properties that can be used throughout the POM as a substitution, and
	   are used as filters in resources if enabled.
	   The format is <code>&lt;name&gt;value&lt;/name&gt;</code>.*/
	Properties *XMLProperties `xml:"properties,omitempty"`

	/* DependencyManagement Default dependency information for projects that inherit from this one. The
	   dependencies in this section are not immediately resolved. Instead, when a POM derived
	   from this one declares a dependency described by a matching groupId and artifactId, the
	   version and other values from this section are used for that dependency if they were not
	   already specified.*/
	DependencyManagement *DependencyManagement `xml:"dependencyManagement,omitempty"`

	/* Dependencies This element describes all of the dependencies associated with a
	   project.
	   These dependencies are used to construct a classpath for your
	   project during the build process. They are automatically downloaded from the
	   repositories defined in this project.
	   See <a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">the
	   dependency mechanism</a> for more information.*/
	Dependencies *SequenceDependency `xml:"dependencies,omitempty"`

	/* Repositories The lists of the remote repositories for discovering dependencies and
	   extensions.*/
	Repositories *SequenceRepository `xml:"repositories,omitempty"`

	/* PluginRepositories The lists of the remote repositories for discovering plugins for builds and
	   reports.*/
	PluginRepositories *SequencePluginRepository `xml:"pluginRepositories,omitempty"`

	/* Reports <b>Deprecated</b>. Now ignored by Maven.*/
	Reports *XMLInner `xml:"reports,omitempty"`

	/* Reporting This element includes the specification of report plugins to use
	   to generate the reports on the Maven-generated site.
	   These reports will be run when a user executes <code>mvn site</code>.
	   All of the reports will be included in the navigation bar for browsing.*/
	Reporting *Reporting `xml:"reporting,omitempty"`

	Comment string `xml:",comment"`
}

// GetID Gets the value of ID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetID(); ok {
//        fmt.Println(value)
//    }
func (a *Profile) GetID() (returnValue string, exists bool) {
	if a.ID != nil {
		return *a.ID, true
	}
	return "", false
}

// SetID will overwrite whatever value is currently set for ID.
// Usage:
// a.SetID("")
func (a *Profile) SetID(value string) {
	copy := value
	a.ID = &copy

}

// GetActivation Gets the value of Activation and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetActivation(); ok {
//        fmt.Println(value)
//    }
func (a *Profile) GetActivation() (returnValue Activation, exists bool) {
	if a.Activation != nil {
		return *a.Activation, true
	}
	return Activation{}, false
}

// SetActivation will overwrite whatever value is currently set for Activation.
// Usage:
// a.SetActivation(Activation{})
func (a *Profile) SetActivation(value Activation) {
	copy := value
	a.Activation = &copy

}

// GetBuild Gets the value of Build and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetBuild(); ok {
//        fmt.Println(value)
//    }
func (a *Profile) GetBuild() (returnValue BuildBase, exists bool) {
	if a.Build != nil {
		return *a.Build, true
	}
	return BuildBase{}, false
}

// SetBuild will overwrite whatever value is currently set for Build.
// Usage:
// a.SetBuild(BuildBase{})
func (a *Profile) SetBuild(value BuildBase) {
	copy := value
	a.Build = &copy

}

// GetModules Gets the value of Modules and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetModules(); ok {
//        fmt.Println(value)
//    }
func (a *Profile) GetModules() (returnValue SequenceModule, exists bool) {
	if a.Modules != nil {
		return *a.Modules, true
	}
	return SequenceModule{}, false
}

// SetModules will overwrite whatever value is currently set for Modules.
// Usage:
// a.SetModules(SequenceModule{})
func (a *Profile) SetModules(value SequenceModule) {
	copy := value
	a.Modules = &copy

}

// GetDistributionManagement Gets the value of DistributionManagement and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetDistributionManagement(); ok {
//        fmt.Println(value)
//    }
func (a *Profile) GetDistributionManagement() (returnValue DistributionManagement, exists bool) {
	if a.DistributionManagement != nil {
		return *a.DistributionManagement, true
	}
	return DistributionManagement{}, false
}

// SetDistributionManagement will overwrite whatever value is currently set for DistributionManagement.
// Usage:
// a.SetDistributionManagement(DistributionManagement{})
func (a *Profile) SetDistributionManagement(value DistributionManagement) {
	copy := value
	a.DistributionManagement = &copy

}

// GetProperties Gets the value of Properties and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetProperties(); ok {
//        fmt.Println(value)
//    }
func (a *Profile) GetProperties() (returnValue XMLProperties, exists bool) {
	if a.Properties != nil {
		return *a.Properties, true
	}
	return XMLProperties{}, false
}

// SetProperties will overwrite whatever value is currently set for Properties.
// Usage:
// a.SetProperties(XMLProperties{})
func (a *Profile) SetProperties(value XMLProperties) {
	copy := value
	a.Properties = &copy

}

// GetDependencyManagement Gets the value of DependencyManagement and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetDependencyManagement(); ok {
//        fmt.Println(value)
//    }
func (a *Profile) GetDependencyManagement() (returnValue DependencyManagement, exists bool) {
	if a.DependencyManagement != nil {
		return *a.DependencyManagement, true
	}
	return DependencyManagement{}, false
}

// SetDependencyManagement will overwrite whatever value is currently set for DependencyManagement.
// Usage:
// a.SetDependencyManagement(DependencyManagement{})
func (a *Profile) SetDependencyManagement(value DependencyManagement) {
	copy := value
	a.DependencyManagement = &copy

}

// GetDependencies Gets the value of Dependencies and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetDependencies(); ok {
//        fmt.Println(value)
//    }
func (a *Profile) GetDependencies() (returnValue SequenceDependency, exists bool) {
	if a.Dependencies != nil {
		return *a.Dependencies, true
	}
	return SequenceDependency{}, false
}

// SetDependencies will overwrite whatever value is currently set for Dependencies.
// Usage:
// a.SetDependencies(SequenceDependency{})
func (a *Profile) SetDependencies(value SequenceDependency) {
	copy := value
	a.Dependencies = &copy

}

// GetRepositories Gets the value of Repositories and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetRepositories(); ok {
//        fmt.Println(value)
//    }
func (a *Profile) GetRepositories() (returnValue SequenceRepository, exists bool) {
	if a.Repositories != nil {
		return *a.Repositories, true
	}
	return SequenceRepository{}, false
}

// SetRepositories will overwrite whatever value is currently set for Repositories.
// Usage:
// a.SetRepositories(SequenceRepository{})
func (a *Profile) SetRepositories(value SequenceRepository) {
	copy := value
	a.Repositories = &copy

}

// GetPluginRepositories Gets the value of PluginRepositories and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetPluginRepositories(); ok {
//        fmt.Println(value)
//    }
func (a *Profile) GetPluginRepositories() (returnValue SequencePluginRepository, exists bool) {
	if a.PluginRepositories != nil {
		return *a.PluginRepositories, true
	}
	return SequencePluginRepository{}, false
}

// SetPluginRepositories will overwrite whatever value is currently set for PluginRepositories.
// Usage:
// a.SetPluginRepositories(SequencePluginRepository{})
func (a *Profile) SetPluginRepositories(value SequencePluginRepository) {
	copy := value
	a.PluginRepositories = &copy

}

// GetReports Gets the value of Reports and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetReports(); ok {
//        fmt.Println(value)
//    }
func (a *Profile) GetReports() (returnValue XMLInner, exists bool) {
	if a.Reports != nil {
		return *a.Reports, true
	}
	return XMLInner{}, false
}

// SetReports will overwrite whatever value is currently set for Reports.
// Usage:
// a.SetReports(XMLInner{})
func (a *Profile) SetReports(value XMLInner) {
	copy := value
	a.Reports = &copy

}

// GetReporting Gets the value of Reporting and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetReporting(); ok {
//        fmt.Println(value)
//    }
func (a *Profile) GetReporting() (returnValue Reporting, exists bool) {
	if a.Reporting != nil {
		return *a.Reporting, true
	}
	return Reporting{}, false
}

// SetReporting will overwrite whatever value is currently set for Reporting.
// Usage:
// a.SetReporting(Reporting{})
func (a *Profile) SetReporting(value Reporting) {
	copy := value
	a.Reporting = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *Profile) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *Profile) SetComment(value string) {
	a.Comment = value

}

// Activation The conditions within the build runtime environment which will trigger the
//        automatic inclusion of the build profile. Multiple conditions can be defined, which must
//        be all satisfied to activate the profile.
type Activation struct {

	/* ActiveByDefault If set to true, this profile will be active unless another profile in this
	   pom is activated using the command line -P option or by one of that profile's
	   activators.*/
	ActiveByDefault *bool `xml:"activeByDefault,omitempty"`

	/* Jdk Specifies that this profile will be activated when a matching JDK is detected.
	   For example, <code>1.4</code> only activates on JDKs versioned 1.4,
	   while <code>!1.4</code> matches any JDK that is not version 1.4. Ranges are supported too:
	   <code>[1.5,)</code> activates when the JDK is 1.5 minimum.*/
	Jdk *string `xml:"jdk,omitempty"`

	/* Os Specifies that this profile will be activated when matching operating system
	   attributes are detected.*/
	Os *ActivationOS `xml:"os,omitempty"`

	/* Property Specifies that this profile will be activated when this system property is
	   specified.*/
	Property *ActivationProperty `xml:"property,omitempty"`

	/* File Specifies that this profile will be activated based on existence of a file.*/
	File *ActivationFile `xml:"file,omitempty"`

	Comment string `xml:",comment"`
}

// GetActiveByDefault Gets the value of ActiveByDefault and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetActiveByDefault(); ok {
//        fmt.Println(value)
//    }
func (a *Activation) GetActiveByDefault() (returnValue bool, exists bool) {
	if a.ActiveByDefault != nil {
		return *a.ActiveByDefault, true
	}
	return false, false
}

// SetActiveByDefault will overwrite whatever value is currently set for ActiveByDefault.
// Usage:
// a.SetActiveByDefault(false)
func (a *Activation) SetActiveByDefault(value bool) {
	copy := value
	a.ActiveByDefault = &copy

}

// GetJdk Gets the value of Jdk and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetJdk(); ok {
//        fmt.Println(value)
//    }
func (a *Activation) GetJdk() (returnValue string, exists bool) {
	if a.Jdk != nil {
		return *a.Jdk, true
	}
	return "", false
}

// SetJdk will overwrite whatever value is currently set for Jdk.
// Usage:
// a.SetJdk("")
func (a *Activation) SetJdk(value string) {
	copy := value
	a.Jdk = &copy

}

// GetOs Gets the value of Os and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetOs(); ok {
//        fmt.Println(value)
//    }
func (a *Activation) GetOs() (returnValue ActivationOS, exists bool) {
	if a.Os != nil {
		return *a.Os, true
	}
	return ActivationOS{}, false
}

// SetOs will overwrite whatever value is currently set for Os.
// Usage:
// a.SetOs(ActivationOS{})
func (a *Activation) SetOs(value ActivationOS) {
	copy := value
	a.Os = &copy

}

// GetProperty Gets the value of Property and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetProperty(); ok {
//        fmt.Println(value)
//    }
func (a *Activation) GetProperty() (returnValue ActivationProperty, exists bool) {
	if a.Property != nil {
		return *a.Property, true
	}
	return ActivationProperty{}, false
}

// SetProperty will overwrite whatever value is currently set for Property.
// Usage:
// a.SetProperty(ActivationProperty{})
func (a *Activation) SetProperty(value ActivationProperty) {
	copy := value
	a.Property = &copy

}

// GetFile Gets the value of File and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetFile(); ok {
//        fmt.Println(value)
//    }
func (a *Activation) GetFile() (returnValue ActivationFile, exists bool) {
	if a.File != nil {
		return *a.File, true
	}
	return ActivationFile{}, false
}

// SetFile will overwrite whatever value is currently set for File.
// Usage:
// a.SetFile(ActivationFile{})
func (a *Activation) SetFile(value ActivationFile) {
	copy := value
	a.File = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *Activation) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *Activation) SetComment(value string) {
	a.Comment = value

}

// ActivationProperty This is the property specification used to activate a profile. If the value field
//        is empty, then the existence of the named property will activate the profile, otherwise it
//        does a case-sensitive match against the property value as well.
type ActivationProperty struct {

	/* Name The name of the property to be used to activate a profile.*/
	Name *string `xml:"name,omitempty"`

	/* Value The value of the property required to activate a profile.*/
	Value *string `xml:"value,omitempty"`

	Comment string `xml:",comment"`
}

// GetName Gets the value of Name and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetName(); ok {
//        fmt.Println(value)
//    }
func (a *ActivationProperty) GetName() (returnValue string, exists bool) {
	if a.Name != nil {
		return *a.Name, true
	}
	return "", false
}

// SetName will overwrite whatever value is currently set for Name.
// Usage:
// a.SetName("")
func (a *ActivationProperty) SetName(value string) {
	copy := value
	a.Name = &copy

}

// GetValue Gets the value of Value and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetValue(); ok {
//        fmt.Println(value)
//    }
func (a *ActivationProperty) GetValue() (returnValue string, exists bool) {
	if a.Value != nil {
		return *a.Value, true
	}
	return "", false
}

// SetValue will overwrite whatever value is currently set for Value.
// Usage:
// a.SetValue("")
func (a *ActivationProperty) SetValue(value string) {
	copy := value
	a.Value = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *ActivationProperty) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *ActivationProperty) SetComment(value string) {
	a.Comment = value

}

// ActivationFile This is the file specification used to activate the profile. The <code>missing</code> value
//        is the location of a file that needs to exist, and if it doesn't, the profile will be
//        activated. On the other hand, <code>exists</code> will test for the existence of the file and if it is
//        there, the profile will be activated.<br>
//        Variable interpolation for these file specifications is limited to <code>${basedir}</code>,
//        System properties and request properties.
type ActivationFile struct {

	/* Missing The name of the file that must be missing to activate the
	   profile.*/
	Missing *string `xml:"missing,omitempty"`

	/* Exists The name of the file that must exist to activate the profile.*/
	Exists *string `xml:"exists,omitempty"`

	Comment string `xml:",comment"`
}

// GetMissing Gets the value of Missing and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetMissing(); ok {
//        fmt.Println(value)
//    }
func (a *ActivationFile) GetMissing() (returnValue string, exists bool) {
	if a.Missing != nil {
		return *a.Missing, true
	}
	return "", false
}

// SetMissing will overwrite whatever value is currently set for Missing.
// Usage:
// a.SetMissing("")
func (a *ActivationFile) SetMissing(value string) {
	copy := value
	a.Missing = &copy

}

// GetExists Gets the value of Exists and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetExists(); ok {
//        fmt.Println(value)
//    }
func (a *ActivationFile) GetExists() (returnValue string, exists bool) {
	if a.Exists != nil {
		return *a.Exists, true
	}
	return "", false
}

// SetExists will overwrite whatever value is currently set for Exists.
// Usage:
// a.SetExists("")
func (a *ActivationFile) SetExists(value string) {
	copy := value
	a.Exists = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *ActivationFile) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *ActivationFile) SetComment(value string) {
	a.Comment = value

}

// ActivationOS This is an activator which will detect an operating system's attributes in order
//        to activate its profile.
type ActivationOS struct {

	/* Name The name of the operating system to be used to activate the profile. This must be an exact match
	   of the <code>${os.name}</code> Java property, such as <code>Windows XP</code>.*/
	Name *string `xml:"name,omitempty"`

	/* Family The general family of the OS to be used to activate the profile, such as
	   <code>windows</code> or <code>unix</code>.*/
	Family *string `xml:"family,omitempty"`

	/* Arch The architecture of the operating system to be used to activate the
	   profile.*/
	Arch *string `xml:"arch,omitempty"`

	/* Version The version of the operating system to be used to activate the
	   profile.*/
	Version *string `xml:"version,omitempty"`

	Comment string `xml:",comment"`
}

// GetName Gets the value of Name and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetName(); ok {
//        fmt.Println(value)
//    }
func (a *ActivationOS) GetName() (returnValue string, exists bool) {
	if a.Name != nil {
		return *a.Name, true
	}
	return "", false
}

// SetName will overwrite whatever value is currently set for Name.
// Usage:
// a.SetName("")
func (a *ActivationOS) SetName(value string) {
	copy := value
	a.Name = &copy

}

// GetFamily Gets the value of Family and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetFamily(); ok {
//        fmt.Println(value)
//    }
func (a *ActivationOS) GetFamily() (returnValue string, exists bool) {
	if a.Family != nil {
		return *a.Family, true
	}
	return "", false
}

// SetFamily will overwrite whatever value is currently set for Family.
// Usage:
// a.SetFamily("")
func (a *ActivationOS) SetFamily(value string) {
	copy := value
	a.Family = &copy

}

// GetArch Gets the value of Arch and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetArch(); ok {
//        fmt.Println(value)
//    }
func (a *ActivationOS) GetArch() (returnValue string, exists bool) {
	if a.Arch != nil {
		return *a.Arch, true
	}
	return "", false
}

// SetArch will overwrite whatever value is currently set for Arch.
// Usage:
// a.SetArch("")
func (a *ActivationOS) SetArch(value string) {
	copy := value
	a.Arch = &copy

}

// GetVersion Gets the value of Version and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetVersion(); ok {
//        fmt.Println(value)
//    }
func (a *ActivationOS) GetVersion() (returnValue string, exists bool) {
	if a.Version != nil {
		return *a.Version, true
	}
	return "", false
}

// SetVersion will overwrite whatever value is currently set for Version.
// Usage:
// a.SetVersion("")
func (a *ActivationOS) SetVersion(value string) {
	copy := value
	a.Version = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *ActivationOS) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *ActivationOS) SetComment(value string) {
	a.Comment = value

}

// Repository A repository contains the information needed for establishing connections with
//        remote repository.
type Repository struct {

	/* Releases How to handle downloading of releases from this repository.*/
	Releases *RepositoryPolicy `xml:"releases,omitempty"`

	/* Snapshots How to handle downloading of snapshots from this repository.*/
	Snapshots *RepositoryPolicy `xml:"snapshots,omitempty"`

	/* Id A unique identifier for a repository. This is used to match the repository
	   to configuration in the <code>settings.xml</code> file, for example. Furthermore, the identifier is
	   used during POM inheritance and profile injection to detect repositories that should be merged.*/
	ID *string `xml:"id,omitempty"`

	/* Name Human readable name of the repository.*/
	Name *string `xml:"name,omitempty"`

	/* Url The url of the repository, in the form <code>protocol://hostname/path</code>.*/
	URL *string `xml:"url,omitempty"`

	/* Layout The type of layout this repository uses for locating and storing artifacts -
	   can be <code>legacy</code> or <code>default</code>.*/
	Layout *string `xml:"layout,omitempty"`

	Comment string `xml:",comment"`
}

// GetReleases Gets the value of Releases and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetReleases(); ok {
//        fmt.Println(value)
//    }
func (a *Repository) GetReleases() (returnValue RepositoryPolicy, exists bool) {
	if a.Releases != nil {
		return *a.Releases, true
	}
	return RepositoryPolicy{}, false
}

// SetReleases will overwrite whatever value is currently set for Releases.
// Usage:
// a.SetReleases(RepositoryPolicy{})
func (a *Repository) SetReleases(value RepositoryPolicy) {
	copy := value
	a.Releases = &copy

}

// GetSnapshots Gets the value of Snapshots and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetSnapshots(); ok {
//        fmt.Println(value)
//    }
func (a *Repository) GetSnapshots() (returnValue RepositoryPolicy, exists bool) {
	if a.Snapshots != nil {
		return *a.Snapshots, true
	}
	return RepositoryPolicy{}, false
}

// SetSnapshots will overwrite whatever value is currently set for Snapshots.
// Usage:
// a.SetSnapshots(RepositoryPolicy{})
func (a *Repository) SetSnapshots(value RepositoryPolicy) {
	copy := value
	a.Snapshots = &copy

}

// GetID Gets the value of ID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetID(); ok {
//        fmt.Println(value)
//    }
func (a *Repository) GetID() (returnValue string, exists bool) {
	if a.ID != nil {
		return *a.ID, true
	}
	return "", false
}

// SetID will overwrite whatever value is currently set for ID.
// Usage:
// a.SetID("")
func (a *Repository) SetID(value string) {
	copy := value
	a.ID = &copy

}

// GetName Gets the value of Name and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetName(); ok {
//        fmt.Println(value)
//    }
func (a *Repository) GetName() (returnValue string, exists bool) {
	if a.Name != nil {
		return *a.Name, true
	}
	return "", false
}

// SetName will overwrite whatever value is currently set for Name.
// Usage:
// a.SetName("")
func (a *Repository) SetName(value string) {
	copy := value
	a.Name = &copy

}

// GetURL Gets the value of URL and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetURL(); ok {
//        fmt.Println(value)
//    }
func (a *Repository) GetURL() (returnValue string, exists bool) {
	if a.URL != nil {
		return *a.URL, true
	}
	return "", false
}

// SetURL will overwrite whatever value is currently set for URL.
// Usage:
// a.SetURL("")
func (a *Repository) SetURL(value string) {
	copy := value
	a.URL = &copy

}

// GetLayout Gets the value of Layout and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetLayout(); ok {
//        fmt.Println(value)
//    }
func (a *Repository) GetLayout() (returnValue string, exists bool) {
	if a.Layout != nil {
		return *a.Layout, true
	}
	return "", false
}

// SetLayout will overwrite whatever value is currently set for Layout.
// Usage:
// a.SetLayout("")
func (a *Repository) SetLayout(value string) {
	copy := value
	a.Layout = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *Repository) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *Repository) SetComment(value string) {
	a.Comment = value

}

// SequenceResource contains the subelements for iterables in XML
type SequenceResource struct {
	Comment string `xml:",comment"`

	Resource []*Resource `xml:"resource,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceResource) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequenceResource) SetComment(value string) {
	a.Comment = value

}

// GetResource Gets the value of Resource and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetResource(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceResource) GetResource() (returnValue []*Resource) {
	if a.Resource != nil {
		return a.Resource
	}
	return []*Resource{}
}

// SetResource will overwrite whatever value is currently set for Resource.
// Usage:
// a.SetResource(Resource{})
func (a *SequenceResource) SetResource(value []*Resource) {
	a.Resource = value

}

// UpdateResource will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := Resource{ }
// a.UpdateResource(value, 2)
func (a *SequenceResource) UpdateResource(value *Resource, index int) {
	current := a.GetResource()
	if len(current) > index {
		a.Resource[index] = value
	}
	a.Resource = append(current, value)
}

// AddResource adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := Resource{ }
// a.AddResource(value)
func (a *SequenceResource) AddResource(value *Resource) {
	a.Resource = append(a.Resource, value)
}

// SequenceTestResource contains the subelements for iterables in XML
type SequenceTestResource struct {
	Comment string `xml:",comment"`

	TestResource []*Resource `xml:"testResource,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceTestResource) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequenceTestResource) SetComment(value string) {
	a.Comment = value

}

// GetTestResource Gets the value of TestResource and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetTestResource(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceTestResource) GetTestResource() (returnValue []*Resource) {
	if a.TestResource != nil {
		return a.TestResource
	}
	return []*Resource{}
}

// SetTestResource will overwrite whatever value is currently set for TestResource.
// Usage:
// a.SetTestResource(Resource{})
func (a *SequenceTestResource) SetTestResource(value []*Resource) {
	a.TestResource = value

}

// UpdateTestResource will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := Resource{ }
// a.UpdateTestResource(value, 2)
func (a *SequenceTestResource) UpdateTestResource(value *Resource, index int) {
	current := a.GetTestResource()
	if len(current) > index {
		a.TestResource[index] = value
	}
	a.TestResource = append(current, value)
}

// AddTestResource adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := Resource{ }
// a.AddTestResource(value)
func (a *SequenceTestResource) AddTestResource(value *Resource) {
	a.TestResource = append(a.TestResource, value)
}

// SequenceFilter contains the subelements for iterables in XML
type SequenceFilter struct {
	Comment string `xml:",comment"`

	Filter []*string `xml:"filter,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceFilter) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequenceFilter) SetComment(value string) {
	a.Comment = value

}

// GetFilter Gets the value of Filter and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetFilter(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceFilter) GetFilter() (returnValue []*string) {
	if a.Filter != nil {
		return a.Filter
	}
	return []*string{}
}

// SetFilter will overwrite whatever value is currently set for Filter.
// Usage:
// a.SetFilter(string{})
func (a *SequenceFilter) SetFilter(value []*string) {
	a.Filter = value

}

// UpdateFilter will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := string{ }
// a.UpdateFilter(value, 2)
func (a *SequenceFilter) UpdateFilter(value *string, index int) {
	current := a.GetFilter()
	if len(current) > index {
		a.Filter[index] = value
	}
	a.Filter = append(current, value)
}

// AddFilter adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := string{ }
// a.AddFilter(value)
func (a *SequenceFilter) AddFilter(value *string) {
	a.Filter = append(a.Filter, value)
}

// BuildBase Generic informations for a build.
type BuildBase struct {

	/* DefaultGoal The default goal (or phase in Maven 2) to execute when none is specified for
	   the project. Note that in case of a multi-module build, only the default goal of the top-level
	   project is relevant, i.e. the default goals of child modules are ignored. Since Maven 3,
	   multiple goals/phases can be separated by whitespace.*/
	DefaultGoal *string `xml:"defaultGoal,omitempty"`

	/* Resources This element describes all of the classpath resources such as properties
	   files associated with a project. These resources are often included in the final
	   package.
	   The default value is <code>src/main/resources</code>.*/
	Resources *SequenceResource `xml:"resources,omitempty"`

	/* TestResources This element describes all of the classpath resources such as properties
	   files associated with a project's unit tests.
	   The default value is <code>src/test/resources</code>.*/
	TestResources *SequenceTestResource `xml:"testResources,omitempty"`

	/* Directory The directory where all files generated by the build are placed.
	   The default value is <code>target</code>.*/
	Directory *string `xml:"directory,omitempty"`

	/* FinalName The filename (excluding the extension, and with no path information) that
	   the produced artifact will be called.
	   The default value is <code>${artifactId}-${version}</code>.*/
	FinalName *string `xml:"finalName,omitempty"`

	/* Filters The list of filter properties files that are used when filtering is enabled.*/
	Filters *SequenceFilter `xml:"filters,omitempty"`

	/* PluginManagement Default plugin information to be made available for reference by projects
	   derived from this one. This plugin configuration will not be resolved or bound to the
	   lifecycle unless referenced. Any local configuration for a given plugin will override
	   the plugin's entire definition here.*/
	PluginManagement *PluginManagement `xml:"pluginManagement,omitempty"`

	/* Plugins The list of plugins to use.*/
	Plugins *SequencePlugin `xml:"plugins,omitempty"`

	Comment string `xml:",comment"`
}

// GetDefaultGoal Gets the value of DefaultGoal and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetDefaultGoal(); ok {
//        fmt.Println(value)
//    }
func (a *BuildBase) GetDefaultGoal() (returnValue string, exists bool) {
	if a.DefaultGoal != nil {
		return *a.DefaultGoal, true
	}
	return "", false
}

// SetDefaultGoal will overwrite whatever value is currently set for DefaultGoal.
// Usage:
// a.SetDefaultGoal("")
func (a *BuildBase) SetDefaultGoal(value string) {
	copy := value
	a.DefaultGoal = &copy

}

// GetResources Gets the value of Resources and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetResources(); ok {
//        fmt.Println(value)
//    }
func (a *BuildBase) GetResources() (returnValue SequenceResource, exists bool) {
	if a.Resources != nil {
		return *a.Resources, true
	}
	return SequenceResource{}, false
}

// SetResources will overwrite whatever value is currently set for Resources.
// Usage:
// a.SetResources(SequenceResource{})
func (a *BuildBase) SetResources(value SequenceResource) {
	copy := value
	a.Resources = &copy

}

// GetTestResources Gets the value of TestResources and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetTestResources(); ok {
//        fmt.Println(value)
//    }
func (a *BuildBase) GetTestResources() (returnValue SequenceTestResource, exists bool) {
	if a.TestResources != nil {
		return *a.TestResources, true
	}
	return SequenceTestResource{}, false
}

// SetTestResources will overwrite whatever value is currently set for TestResources.
// Usage:
// a.SetTestResources(SequenceTestResource{})
func (a *BuildBase) SetTestResources(value SequenceTestResource) {
	copy := value
	a.TestResources = &copy

}

// GetDirectory Gets the value of Directory and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetDirectory(); ok {
//        fmt.Println(value)
//    }
func (a *BuildBase) GetDirectory() (returnValue string, exists bool) {
	if a.Directory != nil {
		return *a.Directory, true
	}
	return "", false
}

// SetDirectory will overwrite whatever value is currently set for Directory.
// Usage:
// a.SetDirectory("")
func (a *BuildBase) SetDirectory(value string) {
	copy := value
	a.Directory = &copy

}

// GetFinalName Gets the value of FinalName and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetFinalName(); ok {
//        fmt.Println(value)
//    }
func (a *BuildBase) GetFinalName() (returnValue string, exists bool) {
	if a.FinalName != nil {
		return *a.FinalName, true
	}
	return "", false
}

// SetFinalName will overwrite whatever value is currently set for FinalName.
// Usage:
// a.SetFinalName("")
func (a *BuildBase) SetFinalName(value string) {
	copy := value
	a.FinalName = &copy

}

// GetFilters Gets the value of Filters and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetFilters(); ok {
//        fmt.Println(value)
//    }
func (a *BuildBase) GetFilters() (returnValue SequenceFilter, exists bool) {
	if a.Filters != nil {
		return *a.Filters, true
	}
	return SequenceFilter{}, false
}

// SetFilters will overwrite whatever value is currently set for Filters.
// Usage:
// a.SetFilters(SequenceFilter{})
func (a *BuildBase) SetFilters(value SequenceFilter) {
	copy := value
	a.Filters = &copy

}

// GetPluginManagement Gets the value of PluginManagement and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetPluginManagement(); ok {
//        fmt.Println(value)
//    }
func (a *BuildBase) GetPluginManagement() (returnValue PluginManagement, exists bool) {
	if a.PluginManagement != nil {
		return *a.PluginManagement, true
	}
	return PluginManagement{}, false
}

// SetPluginManagement will overwrite whatever value is currently set for PluginManagement.
// Usage:
// a.SetPluginManagement(PluginManagement{})
func (a *BuildBase) SetPluginManagement(value PluginManagement) {
	copy := value
	a.PluginManagement = &copy

}

// GetPlugins Gets the value of Plugins and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetPlugins(); ok {
//        fmt.Println(value)
//    }
func (a *BuildBase) GetPlugins() (returnValue SequencePlugin, exists bool) {
	if a.Plugins != nil {
		return *a.Plugins, true
	}
	return SequencePlugin{}, false
}

// SetPlugins will overwrite whatever value is currently set for Plugins.
// Usage:
// a.SetPlugins(SequencePlugin{})
func (a *BuildBase) SetPlugins(value SequencePlugin) {
	copy := value
	a.Plugins = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *BuildBase) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *BuildBase) SetComment(value string) {
	a.Comment = value

}

// SequenceExecution contains the subelements for iterables in XML
type SequenceExecution struct {
	Comment string `xml:",comment"`

	Execution []*PluginExecution `xml:"execution,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceExecution) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequenceExecution) SetComment(value string) {
	a.Comment = value

}

// GetExecution Gets the value of Execution and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetExecution(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceExecution) GetExecution() (returnValue []*PluginExecution) {
	if a.Execution != nil {
		return a.Execution
	}
	return []*PluginExecution{}
}

// SetExecution will overwrite whatever value is currently set for Execution.
// Usage:
// a.SetExecution(PluginExecution{})
func (a *SequenceExecution) SetExecution(value []*PluginExecution) {
	a.Execution = value

}

// UpdateExecution will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := PluginExecution{ }
// a.UpdateExecution(value, 2)
func (a *SequenceExecution) UpdateExecution(value *PluginExecution, index int) {
	current := a.GetExecution()
	if len(current) > index {
		a.Execution[index] = value
	}
	a.Execution = append(current, value)
}

// AddExecution adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := PluginExecution{ }
// a.AddExecution(value)
func (a *SequenceExecution) AddExecution(value *PluginExecution) {
	a.Execution = append(a.Execution, value)
}

// Plugin The <code>&lt;plugin&gt;</code> element contains informations required for a plugin.
type Plugin struct {

	/* GroupId The group ID of the plugin in the repository.*/
	GroupID *string `xml:"groupId,omitempty"`

	/* ArtifactId The artifact ID of the plugin in the repository.*/
	ArtifactID *string `xml:"artifactId,omitempty"`

	/* Version The version (or valid range of versions) of the plugin to be used.*/
	Version *string `xml:"version,omitempty"`

	/* Extensions Whether to load Maven extensions (such as packaging and type handlers) from
	   this plugin. For performance reasons, this should only be enabled when necessary. Note: While the type
	   of this field is <code>String</code> for technical reasons, the semantic type is actually
	   <code>Boolean</code>. Default value is <code>false</code>.*/
	Extensions *string `xml:"extensions,omitempty"`

	/* Executions Multiple specifications of a set of goals to execute during the build
	   lifecycle, each having (possibly) a different configuration.*/
	Executions *SequenceExecution `xml:"executions,omitempty"`

	/* Dependencies Additional dependencies that this project needs to introduce to the plugin's
	   classloader.*/
	Dependencies *SequenceDependency `xml:"dependencies,omitempty"`

	/* Goals <b>Deprecated</b>. Unused by Maven.*/
	Goals *XMLInner `xml:"goals,omitempty"`

	/* Inherited Whether any configuration should be propagated to child POMs. Note: While the type
	   of this field is <code>String</code> for technical reasons, the semantic type is actually
	   <code>Boolean</code>. Default value is <code>true</code>.*/
	Inherited *string `xml:"inherited,omitempty"`

	/* Configuration <p>The configuration as DOM object.</p>
	   <p>By default, every element content is trimmed, but starting with Maven 3.1.0, you can add
	   <code>xml:space="preserve"</code> to elements you want to preserve whitespace.</p>
	   <p>You can control how child POMs inherit configuration from parent POMs by adding <code>combine.children</code>
	   or <code>combine.self</code> attributes to the children of the configuration element:</p>
	   <ul>
	   <li><code>combine.children</code>: available values are <code>merge</code> (default) and <code>append</code>,</li>
	   <li><code>combine.self</code>: available values are <code>merge</code> (default) and <code>override</code>.</li>
	   </ul>
	   <p>See <a href="https://maven.apache.org/pom.html#Plugins">POM Reference documentation</a> and
	   <a href="https://codehaus-plexus.github.io/plexus-utils/apidocs/org/codehaus/plexus/util/xml/Xpp3DomUtils.html">Xpp3DomUtils</a>
	   for more information.</p>*/
	Configuration *XMLInner `xml:"configuration,omitempty"`

	Comment string `xml:",comment"`
}

// GetGroupID Gets the value of GroupID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetGroupID(); ok {
//        fmt.Println(value)
//    }
func (a *Plugin) GetGroupID() (returnValue string, exists bool) {
	if a.GroupID != nil {
		return *a.GroupID, true
	}
	return "", false
}

// SetGroupID will overwrite whatever value is currently set for GroupID.
// Usage:
// a.SetGroupID("")
func (a *Plugin) SetGroupID(value string) {
	copy := value
	a.GroupID = &copy

}

// GetArtifactID Gets the value of ArtifactID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetArtifactID(); ok {
//        fmt.Println(value)
//    }
func (a *Plugin) GetArtifactID() (returnValue string, exists bool) {
	if a.ArtifactID != nil {
		return *a.ArtifactID, true
	}
	return "", false
}

// SetArtifactID will overwrite whatever value is currently set for ArtifactID.
// Usage:
// a.SetArtifactID("")
func (a *Plugin) SetArtifactID(value string) {
	copy := value
	a.ArtifactID = &copy

}

// GetVersion Gets the value of Version and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetVersion(); ok {
//        fmt.Println(value)
//    }
func (a *Plugin) GetVersion() (returnValue string, exists bool) {
	if a.Version != nil {
		return *a.Version, true
	}
	return "", false
}

// SetVersion will overwrite whatever value is currently set for Version.
// Usage:
// a.SetVersion("")
func (a *Plugin) SetVersion(value string) {
	copy := value
	a.Version = &copy

}

// GetExtensions Gets the value of Extensions and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetExtensions(); ok {
//        fmt.Println(value)
//    }
func (a *Plugin) GetExtensions() (returnValue string, exists bool) {
	if a.Extensions != nil {
		return *a.Extensions, true
	}
	return "", false
}

// SetExtensions will overwrite whatever value is currently set for Extensions.
// Usage:
// a.SetExtensions("")
func (a *Plugin) SetExtensions(value string) {
	copy := value
	a.Extensions = &copy

}

// GetExecutions Gets the value of Executions and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetExecutions(); ok {
//        fmt.Println(value)
//    }
func (a *Plugin) GetExecutions() (returnValue SequenceExecution, exists bool) {
	if a.Executions != nil {
		return *a.Executions, true
	}
	return SequenceExecution{}, false
}

// SetExecutions will overwrite whatever value is currently set for Executions.
// Usage:
// a.SetExecutions(SequenceExecution{})
func (a *Plugin) SetExecutions(value SequenceExecution) {
	copy := value
	a.Executions = &copy

}

// GetDependencies Gets the value of Dependencies and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetDependencies(); ok {
//        fmt.Println(value)
//    }
func (a *Plugin) GetDependencies() (returnValue SequenceDependency, exists bool) {
	if a.Dependencies != nil {
		return *a.Dependencies, true
	}
	return SequenceDependency{}, false
}

// SetDependencies will overwrite whatever value is currently set for Dependencies.
// Usage:
// a.SetDependencies(SequenceDependency{})
func (a *Plugin) SetDependencies(value SequenceDependency) {
	copy := value
	a.Dependencies = &copy

}

// GetGoals Gets the value of Goals and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetGoals(); ok {
//        fmt.Println(value)
//    }
func (a *Plugin) GetGoals() (returnValue XMLInner, exists bool) {
	if a.Goals != nil {
		return *a.Goals, true
	}
	return XMLInner{}, false
}

// SetGoals will overwrite whatever value is currently set for Goals.
// Usage:
// a.SetGoals(XMLInner{})
func (a *Plugin) SetGoals(value XMLInner) {
	copy := value
	a.Goals = &copy

}

// GetInherited Gets the value of Inherited and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetInherited(); ok {
//        fmt.Println(value)
//    }
func (a *Plugin) GetInherited() (returnValue string, exists bool) {
	if a.Inherited != nil {
		return *a.Inherited, true
	}
	return "", false
}

// SetInherited will overwrite whatever value is currently set for Inherited.
// Usage:
// a.SetInherited("")
func (a *Plugin) SetInherited(value string) {
	copy := value
	a.Inherited = &copy

}

// GetConfiguration Gets the value of Configuration and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetConfiguration(); ok {
//        fmt.Println(value)
//    }
func (a *Plugin) GetConfiguration() (returnValue XMLInner, exists bool) {
	if a.Configuration != nil {
		return *a.Configuration, true
	}
	return XMLInner{}, false
}

// SetConfiguration will overwrite whatever value is currently set for Configuration.
// Usage:
// a.SetConfiguration(XMLInner{})
func (a *Plugin) SetConfiguration(value XMLInner) {
	copy := value
	a.Configuration = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *Plugin) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *Plugin) SetComment(value string) {
	a.Comment = value

}

// SequenceGoal contains the subelements for iterables in XML
type SequenceGoal struct {
	Comment string `xml:",comment"`

	Goal []*string `xml:"goal,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceGoal) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequenceGoal) SetComment(value string) {
	a.Comment = value

}

// GetGoal Gets the value of Goal and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetGoal(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceGoal) GetGoal() (returnValue []*string) {
	if a.Goal != nil {
		return a.Goal
	}
	return []*string{}
}

// SetGoal will overwrite whatever value is currently set for Goal.
// Usage:
// a.SetGoal(string{})
func (a *SequenceGoal) SetGoal(value []*string) {
	a.Goal = value

}

// UpdateGoal will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := string{ }
// a.UpdateGoal(value, 2)
func (a *SequenceGoal) UpdateGoal(value *string, index int) {
	current := a.GetGoal()
	if len(current) > index {
		a.Goal[index] = value
	}
	a.Goal = append(current, value)
}

// AddGoal adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := string{ }
// a.AddGoal(value)
func (a *SequenceGoal) AddGoal(value *string) {
	a.Goal = append(a.Goal, value)
}

// PluginExecution The <code>&lt;execution&gt;</code> element contains informations required for the
//        execution of a plugin.
type PluginExecution struct {

	/* Id The identifier of this execution for labelling the goals during the build,
	   and for matching executions to merge during inheritance and profile injection.*/
	ID *string `xml:"id,omitempty"`

	/* Phase The build lifecycle phase to bind the goals in this execution to. If omitted,
	   the goals will be bound to the default phase specified by the plugin.*/
	Phase *string `xml:"phase,omitempty"`

	/* Goals The goals to execute with the given configuration.*/
	Goals *SequenceGoal `xml:"goals,omitempty"`

	/* Inherited Whether any configuration should be propagated to child POMs. Note: While the type
	   of this field is <code>String</code> for technical reasons, the semantic type is actually
	   <code>Boolean</code>. Default value is <code>true</code>.*/
	Inherited *string `xml:"inherited,omitempty"`

	/* Configuration <p>The configuration as DOM object.</p>
	   <p>By default, every element content is trimmed, but starting with Maven 3.1.0, you can add
	   <code>xml:space="preserve"</code> to elements you want to preserve whitespace.</p>
	   <p>You can control how child POMs inherit configuration from parent POMs by adding <code>combine.children</code>
	   or <code>combine.self</code> attributes to the children of the configuration element:</p>
	   <ul>
	   <li><code>combine.children</code>: available values are <code>merge</code> (default) and <code>append</code>,</li>
	   <li><code>combine.self</code>: available values are <code>merge</code> (default) and <code>override</code>.</li>
	   </ul>
	   <p>See <a href="https://maven.apache.org/pom.html#Plugins">POM Reference documentation</a> and
	   <a href="https://codehaus-plexus.github.io/plexus-utils/apidocs/org/codehaus/plexus/util/xml/Xpp3DomUtils.html">Xpp3DomUtils</a>
	   for more information.</p>*/
	Configuration *XMLInner `xml:"configuration,omitempty"`

	Comment string `xml:",comment"`
}

// GetID Gets the value of ID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetID(); ok {
//        fmt.Println(value)
//    }
func (a *PluginExecution) GetID() (returnValue string, exists bool) {
	if a.ID != nil {
		return *a.ID, true
	}
	return "", false
}

// SetID will overwrite whatever value is currently set for ID.
// Usage:
// a.SetID("")
func (a *PluginExecution) SetID(value string) {
	copy := value
	a.ID = &copy

}

// GetPhase Gets the value of Phase and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetPhase(); ok {
//        fmt.Println(value)
//    }
func (a *PluginExecution) GetPhase() (returnValue string, exists bool) {
	if a.Phase != nil {
		return *a.Phase, true
	}
	return "", false
}

// SetPhase will overwrite whatever value is currently set for Phase.
// Usage:
// a.SetPhase("")
func (a *PluginExecution) SetPhase(value string) {
	copy := value
	a.Phase = &copy

}

// GetGoals Gets the value of Goals and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetGoals(); ok {
//        fmt.Println(value)
//    }
func (a *PluginExecution) GetGoals() (returnValue SequenceGoal, exists bool) {
	if a.Goals != nil {
		return *a.Goals, true
	}
	return SequenceGoal{}, false
}

// SetGoals will overwrite whatever value is currently set for Goals.
// Usage:
// a.SetGoals(SequenceGoal{})
func (a *PluginExecution) SetGoals(value SequenceGoal) {
	copy := value
	a.Goals = &copy

}

// GetInherited Gets the value of Inherited and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetInherited(); ok {
//        fmt.Println(value)
//    }
func (a *PluginExecution) GetInherited() (returnValue string, exists bool) {
	if a.Inherited != nil {
		return *a.Inherited, true
	}
	return "", false
}

// SetInherited will overwrite whatever value is currently set for Inherited.
// Usage:
// a.SetInherited("")
func (a *PluginExecution) SetInherited(value string) {
	copy := value
	a.Inherited = &copy

}

// GetConfiguration Gets the value of Configuration and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetConfiguration(); ok {
//        fmt.Println(value)
//    }
func (a *PluginExecution) GetConfiguration() (returnValue XMLInner, exists bool) {
	if a.Configuration != nil {
		return *a.Configuration, true
	}
	return XMLInner{}, false
}

// SetConfiguration will overwrite whatever value is currently set for Configuration.
// Usage:
// a.SetConfiguration(XMLInner{})
func (a *PluginExecution) SetConfiguration(value XMLInner) {
	copy := value
	a.Configuration = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *PluginExecution) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *PluginExecution) SetComment(value string) {
	a.Comment = value

}

// SequenceInclude contains the subelements for iterables in XML
type SequenceInclude struct {
	Comment string `xml:",comment"`

	Include []*string `xml:"include,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceInclude) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequenceInclude) SetComment(value string) {
	a.Comment = value

}

// GetInclude Gets the value of Include and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetInclude(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceInclude) GetInclude() (returnValue []*string) {
	if a.Include != nil {
		return a.Include
	}
	return []*string{}
}

// SetInclude will overwrite whatever value is currently set for Include.
// Usage:
// a.SetInclude(string{})
func (a *SequenceInclude) SetInclude(value []*string) {
	a.Include = value

}

// UpdateInclude will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := string{ }
// a.UpdateInclude(value, 2)
func (a *SequenceInclude) UpdateInclude(value *string, index int) {
	current := a.GetInclude()
	if len(current) > index {
		a.Include[index] = value
	}
	a.Include = append(current, value)
}

// AddInclude adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := string{ }
// a.AddInclude(value)
func (a *SequenceInclude) AddInclude(value *string) {
	a.Include = append(a.Include, value)
}

// SequenceExclude contains the subelements for iterables in XML
type SequenceExclude struct {
	Comment string `xml:",comment"`

	Exclude []*string `xml:"exclude,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceExclude) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequenceExclude) SetComment(value string) {
	a.Comment = value

}

// GetExclude Gets the value of Exclude and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetExclude(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceExclude) GetExclude() (returnValue []*string) {
	if a.Exclude != nil {
		return a.Exclude
	}
	return []*string{}
}

// SetExclude will overwrite whatever value is currently set for Exclude.
// Usage:
// a.SetExclude(string{})
func (a *SequenceExclude) SetExclude(value []*string) {
	a.Exclude = value

}

// UpdateExclude will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := string{ }
// a.UpdateExclude(value, 2)
func (a *SequenceExclude) UpdateExclude(value *string, index int) {
	current := a.GetExclude()
	if len(current) > index {
		a.Exclude[index] = value
	}
	a.Exclude = append(current, value)
}

// AddExclude adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := string{ }
// a.AddExclude(value)
func (a *SequenceExclude) AddExclude(value *string) {
	a.Exclude = append(a.Exclude, value)
}

// Resource This element describes all of the classpath resources associated with a project
//        or unit tests.
type Resource struct {

	/* TargetPath Describe the resource target path. The path is relative to the target/classes
	   directory (i.e. <code>${project.build.outputDirectory}</code>).
	   For example, if you want that resource to appear in a specific package
	   (<code>org.apache.maven.messages</code>), you must specify this
	   element with this value: <code>org/apache/maven/messages</code>.
	   This is not required if you simply put the resources in that directory
	   structure at the source, however.*/
	TargetPath *string `xml:"targetPath,omitempty"`

	/* Filtering Whether resources are filtered to replace tokens with parameterised values or not.
	   The values are taken from the <code>properties</code> element and from the
	   properties in the files listed in the <code>filters</code> element. Note: While the type
	   of this field is <code>String</code> for technical reasons, the semantic type is actually
	   <code>Boolean</code>. Default value is <code>false</code>.*/
	Filtering *string `xml:"filtering,omitempty"`

	/* Directory Describe the directory where the resources are stored. The path is relative
	   to the POM.*/
	Directory *string `xml:"directory,omitempty"`

	/* Includes A list of patterns to include, e.g. <code>**&#47;*.xml</code>.*/
	Includes *SequenceInclude `xml:"includes,omitempty"`

	/* Excludes A list of patterns to exclude, e.g. <code>**&#47;*.xml</code>*/
	Excludes *SequenceExclude `xml:"excludes,omitempty"`

	Comment string `xml:",comment"`
}

// GetTargetPath Gets the value of TargetPath and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetTargetPath(); ok {
//        fmt.Println(value)
//    }
func (a *Resource) GetTargetPath() (returnValue string, exists bool) {
	if a.TargetPath != nil {
		return *a.TargetPath, true
	}
	return "", false
}

// SetTargetPath will overwrite whatever value is currently set for TargetPath.
// Usage:
// a.SetTargetPath("")
func (a *Resource) SetTargetPath(value string) {
	copy := value
	a.TargetPath = &copy

}

// GetFiltering Gets the value of Filtering and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetFiltering(); ok {
//        fmt.Println(value)
//    }
func (a *Resource) GetFiltering() (returnValue string, exists bool) {
	if a.Filtering != nil {
		return *a.Filtering, true
	}
	return "", false
}

// SetFiltering will overwrite whatever value is currently set for Filtering.
// Usage:
// a.SetFiltering("")
func (a *Resource) SetFiltering(value string) {
	copy := value
	a.Filtering = &copy

}

// GetDirectory Gets the value of Directory and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetDirectory(); ok {
//        fmt.Println(value)
//    }
func (a *Resource) GetDirectory() (returnValue string, exists bool) {
	if a.Directory != nil {
		return *a.Directory, true
	}
	return "", false
}

// SetDirectory will overwrite whatever value is currently set for Directory.
// Usage:
// a.SetDirectory("")
func (a *Resource) SetDirectory(value string) {
	copy := value
	a.Directory = &copy

}

// GetIncludes Gets the value of Includes and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetIncludes(); ok {
//        fmt.Println(value)
//    }
func (a *Resource) GetIncludes() (returnValue SequenceInclude, exists bool) {
	if a.Includes != nil {
		return *a.Includes, true
	}
	return SequenceInclude{}, false
}

// SetIncludes will overwrite whatever value is currently set for Includes.
// Usage:
// a.SetIncludes(SequenceInclude{})
func (a *Resource) SetIncludes(value SequenceInclude) {
	copy := value
	a.Includes = &copy

}

// GetExcludes Gets the value of Excludes and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetExcludes(); ok {
//        fmt.Println(value)
//    }
func (a *Resource) GetExcludes() (returnValue SequenceExclude, exists bool) {
	if a.Excludes != nil {
		return *a.Excludes, true
	}
	return SequenceExclude{}, false
}

// SetExcludes will overwrite whatever value is currently set for Excludes.
// Usage:
// a.SetExcludes(SequenceExclude{})
func (a *Resource) SetExcludes(value SequenceExclude) {
	copy := value
	a.Excludes = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *Resource) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *Resource) SetComment(value string) {
	a.Comment = value

}

// PluginManagement Section for management of default plugin information for use in a group of POMs.
type PluginManagement struct {

	/* Plugins The list of plugins to use.*/
	Plugins *SequencePlugin `xml:"plugins,omitempty"`

	Comment string `xml:",comment"`
}

// GetPlugins Gets the value of Plugins and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetPlugins(); ok {
//        fmt.Println(value)
//    }
func (a *PluginManagement) GetPlugins() (returnValue SequencePlugin, exists bool) {
	if a.Plugins != nil {
		return *a.Plugins, true
	}
	return SequencePlugin{}, false
}

// SetPlugins will overwrite whatever value is currently set for Plugins.
// Usage:
// a.SetPlugins(SequencePlugin{})
func (a *PluginManagement) SetPlugins(value SequencePlugin) {
	copy := value
	a.Plugins = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *PluginManagement) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *PluginManagement) SetComment(value string) {
	a.Comment = value

}

// Prerequisites Describes the prerequisites a project can have.
type Prerequisites struct {

	/* Maven For a plugin project (packaging is <code>maven-plugin</code>), the minimum version of
	   Maven required to use the resulting plugin.<br>
	   In Maven 2, this was also specifying the minimum version of Maven required to build a
	   project, but this usage is <b>deprecated</b> in Maven 3 and not checked any more: use
	   the <a href="https://maven.apache.org/enforcer/enforcer-rules/requireMavenVersion.html">Maven Enforcer Plugin's
	   <code>requireMavenVersion</code> rule</a> instead.*/
	Maven *string `xml:"maven,omitempty"`

	Comment string `xml:",comment"`
}

// GetMaven Gets the value of Maven and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetMaven(); ok {
//        fmt.Println(value)
//    }
func (a *Prerequisites) GetMaven() (returnValue string, exists bool) {
	if a.Maven != nil {
		return *a.Maven, true
	}
	return "", false
}

// SetMaven will overwrite whatever value is currently set for Maven.
// Usage:
// a.SetMaven("")
func (a *Prerequisites) SetMaven(value string) {
	copy := value
	a.Maven = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *Prerequisites) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *Prerequisites) SetComment(value string) {
	a.Comment = value

}

// SequenceExtension contains the subelements for iterables in XML
type SequenceExtension struct {
	Comment string `xml:",comment"`

	Extension []*Extension `xml:"extension,omitempty"`
}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceExtension) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *SequenceExtension) SetComment(value string) {
	a.Comment = value

}

// GetExtension Gets the value of Extension and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetExtension(); ok {
//        fmt.Println(value)
//    }
func (a *SequenceExtension) GetExtension() (returnValue []*Extension) {
	if a.Extension != nil {
		return a.Extension
	}
	return []*Extension{}
}

// SetExtension will overwrite whatever value is currently set for Extension.
// Usage:
// a.SetExtension(Extension{})
func (a *SequenceExtension) SetExtension(value []*Extension) {
	a.Extension = value

}

// UpdateExtension will update a sequence at index.  If indx is greater than the
// length of the sequence, we add it to the end.
// Usage:
// value := Extension{ }
// a.UpdateExtension(value, 2)
func (a *SequenceExtension) UpdateExtension(value *Extension, index int) {
	current := a.GetExtension()
	if len(current) > index {
		a.Extension[index] = value
	}
	a.Extension = append(current, value)
}

// AddExtension adds a new element to the sequence.  If the sequence is nil, it is created.
// Usage:
// value := Extension{ }
// a.AddExtension(value)
func (a *SequenceExtension) AddExtension(value *Extension) {
	a.Extension = append(a.Extension, value)
}

// Build The <code>&lt;build&gt;</code> element contains informations required to build the project.
//        Default values are defined in Super POM.
type Build struct {

	/* SourceDirectory This element specifies a directory containing the source of the project. The
	   generated build system will compile the sources from this directory when the project is
	   built. The path given is relative to the project descriptor.
	   The default value is <code>src/main/java</code>.*/
	SourceDirectory *string `xml:"sourceDirectory,omitempty"`

	/* ScriptSourceDirectory This element specifies a directory containing the script sources of the
	   project. This directory is meant to be different from the sourceDirectory, in that its
	   contents will be copied to the output directory in most cases (since scripts are
	   interpreted rather than compiled).
	   The default value is <code>src/main/scripts</code>.*/
	ScriptSourceDirectory *string `xml:"scriptSourceDirectory,omitempty"`

	/* TestSourceDirectory This element specifies a directory containing the unit test source of the
	   project. The generated build system will compile these directories when the project is
	   being tested. The path given is relative to the project descriptor.
	   The default value is <code>src/test/java</code>.*/
	TestSourceDirectory *string `xml:"testSourceDirectory,omitempty"`

	/* OutputDirectory The directory where compiled application classes are placed.
	   The default value is <code>target/classes</code>.*/
	OutputDirectory *string `xml:"outputDirectory,omitempty"`

	/* TestOutputDirectory The directory where compiled test classes are placed.
	   The default value is <code>target/test-classes</code>.*/
	TestOutputDirectory *string `xml:"testOutputDirectory,omitempty"`

	/* Extensions A set of build extensions to use from this project.*/
	Extensions *SequenceExtension `xml:"extensions,omitempty"`

	/* DefaultGoal The default goal (or phase in Maven 2) to execute when none is specified for
	   the project. Note that in case of a multi-module build, only the default goal of the top-level
	   project is relevant, i.e. the default goals of child modules are ignored. Since Maven 3,
	   multiple goals/phases can be separated by whitespace.*/
	DefaultGoal *string `xml:"defaultGoal,omitempty"`

	/* Resources This element describes all of the classpath resources such as properties
	   files associated with a project. These resources are often included in the final
	   package.
	   The default value is <code>src/main/resources</code>.*/
	Resources *SequenceResource `xml:"resources,omitempty"`

	/* TestResources This element describes all of the classpath resources such as properties
	   files associated with a project's unit tests.
	   The default value is <code>src/test/resources</code>.*/
	TestResources *SequenceTestResource `xml:"testResources,omitempty"`

	/* Directory The directory where all files generated by the build are placed.
	   The default value is <code>target</code>.*/
	Directory *string `xml:"directory,omitempty"`

	/* FinalName The filename (excluding the extension, and with no path information) that
	   the produced artifact will be called.
	   The default value is <code>${artifactId}-${version}</code>.*/
	FinalName *string `xml:"finalName,omitempty"`

	/* Filters The list of filter properties files that are used when filtering is enabled.*/
	Filters *SequenceFilter `xml:"filters,omitempty"`

	/* PluginManagement Default plugin information to be made available for reference by projects
	   derived from this one. This plugin configuration will not be resolved or bound to the
	   lifecycle unless referenced. Any local configuration for a given plugin will override
	   the plugin's entire definition here.*/
	PluginManagement *PluginManagement `xml:"pluginManagement,omitempty"`

	/* Plugins The list of plugins to use.*/
	Plugins *SequencePlugin `xml:"plugins,omitempty"`

	Comment string `xml:",comment"`
}

// GetSourceDirectory Gets the value of SourceDirectory and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetSourceDirectory(); ok {
//        fmt.Println(value)
//    }
func (a *Build) GetSourceDirectory() (returnValue string, exists bool) {
	if a.SourceDirectory != nil {
		return *a.SourceDirectory, true
	}
	return "", false
}

// SetSourceDirectory will overwrite whatever value is currently set for SourceDirectory.
// Usage:
// a.SetSourceDirectory("")
func (a *Build) SetSourceDirectory(value string) {
	copy := value
	a.SourceDirectory = &copy

}

// GetScriptSourceDirectory Gets the value of ScriptSourceDirectory and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetScriptSourceDirectory(); ok {
//        fmt.Println(value)
//    }
func (a *Build) GetScriptSourceDirectory() (returnValue string, exists bool) {
	if a.ScriptSourceDirectory != nil {
		return *a.ScriptSourceDirectory, true
	}
	return "", false
}

// SetScriptSourceDirectory will overwrite whatever value is currently set for ScriptSourceDirectory.
// Usage:
// a.SetScriptSourceDirectory("")
func (a *Build) SetScriptSourceDirectory(value string) {
	copy := value
	a.ScriptSourceDirectory = &copy

}

// GetTestSourceDirectory Gets the value of TestSourceDirectory and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetTestSourceDirectory(); ok {
//        fmt.Println(value)
//    }
func (a *Build) GetTestSourceDirectory() (returnValue string, exists bool) {
	if a.TestSourceDirectory != nil {
		return *a.TestSourceDirectory, true
	}
	return "", false
}

// SetTestSourceDirectory will overwrite whatever value is currently set for TestSourceDirectory.
// Usage:
// a.SetTestSourceDirectory("")
func (a *Build) SetTestSourceDirectory(value string) {
	copy := value
	a.TestSourceDirectory = &copy

}

// GetOutputDirectory Gets the value of OutputDirectory and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetOutputDirectory(); ok {
//        fmt.Println(value)
//    }
func (a *Build) GetOutputDirectory() (returnValue string, exists bool) {
	if a.OutputDirectory != nil {
		return *a.OutputDirectory, true
	}
	return "", false
}

// SetOutputDirectory will overwrite whatever value is currently set for OutputDirectory.
// Usage:
// a.SetOutputDirectory("")
func (a *Build) SetOutputDirectory(value string) {
	copy := value
	a.OutputDirectory = &copy

}

// GetTestOutputDirectory Gets the value of TestOutputDirectory and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetTestOutputDirectory(); ok {
//        fmt.Println(value)
//    }
func (a *Build) GetTestOutputDirectory() (returnValue string, exists bool) {
	if a.TestOutputDirectory != nil {
		return *a.TestOutputDirectory, true
	}
	return "", false
}

// SetTestOutputDirectory will overwrite whatever value is currently set for TestOutputDirectory.
// Usage:
// a.SetTestOutputDirectory("")
func (a *Build) SetTestOutputDirectory(value string) {
	copy := value
	a.TestOutputDirectory = &copy

}

// GetExtensions Gets the value of Extensions and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetExtensions(); ok {
//        fmt.Println(value)
//    }
func (a *Build) GetExtensions() (returnValue SequenceExtension, exists bool) {
	if a.Extensions != nil {
		return *a.Extensions, true
	}
	return SequenceExtension{}, false
}

// SetExtensions will overwrite whatever value is currently set for Extensions.
// Usage:
// a.SetExtensions(SequenceExtension{})
func (a *Build) SetExtensions(value SequenceExtension) {
	copy := value
	a.Extensions = &copy

}

// GetDefaultGoal Gets the value of DefaultGoal and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetDefaultGoal(); ok {
//        fmt.Println(value)
//    }
func (a *Build) GetDefaultGoal() (returnValue string, exists bool) {
	if a.DefaultGoal != nil {
		return *a.DefaultGoal, true
	}
	return "", false
}

// SetDefaultGoal will overwrite whatever value is currently set for DefaultGoal.
// Usage:
// a.SetDefaultGoal("")
func (a *Build) SetDefaultGoal(value string) {
	copy := value
	a.DefaultGoal = &copy

}

// GetResources Gets the value of Resources and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetResources(); ok {
//        fmt.Println(value)
//    }
func (a *Build) GetResources() (returnValue SequenceResource, exists bool) {
	if a.Resources != nil {
		return *a.Resources, true
	}
	return SequenceResource{}, false
}

// SetResources will overwrite whatever value is currently set for Resources.
// Usage:
// a.SetResources(SequenceResource{})
func (a *Build) SetResources(value SequenceResource) {
	copy := value
	a.Resources = &copy

}

// GetTestResources Gets the value of TestResources and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetTestResources(); ok {
//        fmt.Println(value)
//    }
func (a *Build) GetTestResources() (returnValue SequenceTestResource, exists bool) {
	if a.TestResources != nil {
		return *a.TestResources, true
	}
	return SequenceTestResource{}, false
}

// SetTestResources will overwrite whatever value is currently set for TestResources.
// Usage:
// a.SetTestResources(SequenceTestResource{})
func (a *Build) SetTestResources(value SequenceTestResource) {
	copy := value
	a.TestResources = &copy

}

// GetDirectory Gets the value of Directory and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetDirectory(); ok {
//        fmt.Println(value)
//    }
func (a *Build) GetDirectory() (returnValue string, exists bool) {
	if a.Directory != nil {
		return *a.Directory, true
	}
	return "", false
}

// SetDirectory will overwrite whatever value is currently set for Directory.
// Usage:
// a.SetDirectory("")
func (a *Build) SetDirectory(value string) {
	copy := value
	a.Directory = &copy

}

// GetFinalName Gets the value of FinalName and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetFinalName(); ok {
//        fmt.Println(value)
//    }
func (a *Build) GetFinalName() (returnValue string, exists bool) {
	if a.FinalName != nil {
		return *a.FinalName, true
	}
	return "", false
}

// SetFinalName will overwrite whatever value is currently set for FinalName.
// Usage:
// a.SetFinalName("")
func (a *Build) SetFinalName(value string) {
	copy := value
	a.FinalName = &copy

}

// GetFilters Gets the value of Filters and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetFilters(); ok {
//        fmt.Println(value)
//    }
func (a *Build) GetFilters() (returnValue SequenceFilter, exists bool) {
	if a.Filters != nil {
		return *a.Filters, true
	}
	return SequenceFilter{}, false
}

// SetFilters will overwrite whatever value is currently set for Filters.
// Usage:
// a.SetFilters(SequenceFilter{})
func (a *Build) SetFilters(value SequenceFilter) {
	copy := value
	a.Filters = &copy

}

// GetPluginManagement Gets the value of PluginManagement and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetPluginManagement(); ok {
//        fmt.Println(value)
//    }
func (a *Build) GetPluginManagement() (returnValue PluginManagement, exists bool) {
	if a.PluginManagement != nil {
		return *a.PluginManagement, true
	}
	return PluginManagement{}, false
}

// SetPluginManagement will overwrite whatever value is currently set for PluginManagement.
// Usage:
// a.SetPluginManagement(PluginManagement{})
func (a *Build) SetPluginManagement(value PluginManagement) {
	copy := value
	a.PluginManagement = &copy

}

// GetPlugins Gets the value of Plugins and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetPlugins(); ok {
//        fmt.Println(value)
//    }
func (a *Build) GetPlugins() (returnValue SequencePlugin, exists bool) {
	if a.Plugins != nil {
		return *a.Plugins, true
	}
	return SequencePlugin{}, false
}

// SetPlugins will overwrite whatever value is currently set for Plugins.
// Usage:
// a.SetPlugins(SequencePlugin{})
func (a *Build) SetPlugins(value SequencePlugin) {
	copy := value
	a.Plugins = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *Build) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *Build) SetComment(value string) {
	a.Comment = value

}

// Extension Describes a build extension to utilise.
type Extension struct {

	/* GroupId The group ID of the extension's artifact.*/
	GroupID *string `xml:"groupId,omitempty"`

	/* ArtifactId The artifact ID of the extension.*/
	ArtifactID *string `xml:"artifactId,omitempty"`

	/* Version The version of the extension.*/
	Version *string `xml:"version,omitempty"`

	Comment string `xml:",comment"`
}

// GetGroupID Gets the value of GroupID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetGroupID(); ok {
//        fmt.Println(value)
//    }
func (a *Extension) GetGroupID() (returnValue string, exists bool) {
	if a.GroupID != nil {
		return *a.GroupID, true
	}
	return "", false
}

// SetGroupID will overwrite whatever value is currently set for GroupID.
// Usage:
// a.SetGroupID("")
func (a *Extension) SetGroupID(value string) {
	copy := value
	a.GroupID = &copy

}

// GetArtifactID Gets the value of ArtifactID and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetArtifactID(); ok {
//        fmt.Println(value)
//    }
func (a *Extension) GetArtifactID() (returnValue string, exists bool) {
	if a.ArtifactID != nil {
		return *a.ArtifactID, true
	}
	return "", false
}

// SetArtifactID will overwrite whatever value is currently set for ArtifactID.
// Usage:
// a.SetArtifactID("")
func (a *Extension) SetArtifactID(value string) {
	copy := value
	a.ArtifactID = &copy

}

// GetVersion Gets the value of Version and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetVersion(); ok {
//        fmt.Println(value)
//    }
func (a *Extension) GetVersion() (returnValue string, exists bool) {
	if a.Version != nil {
		return *a.Version, true
	}
	return "", false
}

// SetVersion will overwrite whatever value is currently set for Version.
// Usage:
// a.SetVersion("")
func (a *Extension) SetVersion(value string) {
	copy := value
	a.Version = &copy

}

// GetComment Gets the value of Comment and returns it.
// If the value does not exist, then the default empty value is returned
// and exists is set to false
// Usage:
//   if value, ok := a.GetComment(); ok {
//        fmt.Println(value)
//    }
func (a *Extension) GetComment() (returnValue string, exists bool) {
	return a.Comment, false
}

// SetComment will overwrite whatever value is currently set for Comment.
// Usage:
// a.SetComment()
func (a *Extension) SetComment(value string) {
	a.Comment = value

}
